# Что такое Node.js. Особенности

Рекомендация к прочтению: "Node.js Design Patterns" by Mario Casciaro, Luciano Mammino.

## Философия Node.js

Значительная часть философии Node.js зафиксировал её создатель - Ryan Dahl. Зафиксирована вот здесь: https://en.wikipedia.org/wiki/List_of_software_development_philosophies

Основные идеи:

**Маленькое ядро** имеет наименьшее из возможных множество функциональных возможностей, оставляя остальное т.н. userland/userspace - экосистеме модулей, живущих вне ядра. Именно этот принцип оказывает огромное влияние на культуру Node.js, предоставляя сообществу свободу экспериментирования и быстрого развития экосистемы. Сохранение функциональности ядра на самом минимуме, является не только удобным для сопровождения продукта, но и оказывает положительное культурное влияние на эволюцию всей экосистемы.

**Маленькие модули**. Модуль имеет фундаментальное згачение в структуре кода программы. Это кирпичик для содания приложений и повторно используемых ,библиотек, называемых **packages**. Один из главных принципов дизайна в Node.js состоит в том, чтобы создавать маленькие модули, не только в терминах размера, но и в терминах **scope**. Принцип повторяет ключевой принцип философии Unix:

- Small is beautiful
- Make each program do one thing well

В npm каждый установленный package имеет своё собственное подмножество зависимостей (set of dependencies), что позволят избегать конфликтов модулей. Благодаря этому возникает беспрецендентный уровень повторного использования компонентов. Хотя такой подход кажется непрактичным из-за большого объёма зависимостей, на практике это приводит к тому, что сложно найти npm package, содержащий более 100 строк кода.

Вот почему важно сохранять маленький размер модулей:

- проще понимать и использовать
- проще тестировать и сопровождать
- отлично можно использовать и в браузере

Всё это выводит принцип Don't repeat yourself (DRY) на новый уровень.

**Small surface area**: модули в Node.js обычно имеют минимальный набор функций. Это приводит к тому, что гораздо проще понять, как использовать такой модуль.

Типовой pattern в Node.js состоит в том, что модуль реализует только одну часть функциональности, например, функцию, или конструктор, предоставляя другим модулям возможность реализовать другие особенности. Это помогает пользователям понимать, что важно, а что не очень важно в конкретной задаче.

Ещё одна характеристика Node.js состоит в том, что модули создаются для использования, а не для расширения. Тот факт, что по сути, в Node.js возможность расширения является заблокированной, кажется очень не гибким, но на практике это приводит к уменьшению прецедентов использования, упрощению реализации и споровождении, а также к увеличению usability.

**Простота и прагматизм**: ключевой принцип - Keep It Simple, Stupid (KISS).

"Simplicity is the ultimate sophistication" - Leonardo da Vinci.

## The Reactor Pattern

Ключевой компонент Node.js - **synchronous event demultiplexer** (также известный как **event notification interface**). Он следит за выполнением блокирующих операций ввода/вывода и, когда какая-нибудь из них (или несколько) завершается, управление передаётся из event demultiplexer в вызывающие его код, который обрабатывает события завершения операций ввода/вывода. После отработки событий (это называется **event loop**), управление снова передаётся demultiplexer-у, который снова отслеживает завершение не блокирующих операций ввода-вывода.

Этот подход позволяет использовать только один поток исполнения (thread) для выполнения параллельных задач, связанных с использованием I/O ресурсов. Но самое главное, этот подход позволяет реализовать модель программирования, в которой не требуется тратить вычислительные ресурсы на межпоточную синхронизацию, которая обычно обходится очень дорого.

Идея **the reactor pattern** состоит в том, что для каждой операции ввода/вывода есть обработчик, который называется **callback**. Соответственно, задача состоит в том, чтобы реагировать на завершение операции ввода/вывода передачей сообщения в связанный с этой операцией обработчик.

Связанные термины: **Event Loop** и **Event Queue**.

Главное достижение The Reactor Pattern состоит в том, что отсутствуют издержки на создание потоков, переключение между ними и на межпоточную синхронизацию.

## Libuv

В каждой операционной системе есть свой собственный механизм для event demultiplexer: **epoll** в Linux, **kqueue** в macOS и **I/O completion port** (IOCP) API в Windows. Однако, в разных операционных системах существуют фундаментальные различия в реализации операций ввода/вывода. Так, например, обычная файловая система в Linux не поддерживает non-blocking операции и, как результат, non-blocking поведение приходится реализовывать в отдельном потоке вне event loop.

Для устранения подобных различий потребовалось реализовать выcокоуровневую абстрацию для **event demultiplexer**. Именно эту задачу и решила команда Node.js разработав библиотеку **libuv**, портированную на все основные операционные системы. Пожалуй, именно эта библиотека является наиболее важной особенностью Node.js.

Рекомендуется к прочтению книга [An Introduction to libuv](https://nikhilm.github.io/uvbook/An%20Introduction%20to%20libuv.pdf) by _Nikhil Marathe_.

## Packages

Существует огромное количество packages, включая net (TCP/IP), dgram (UDP), http и https, crypto (OpenSSL).

При необходимости, мы можем подключать native code, разработанный на C/C++ посредством N-API interface.

Многие современные JavaScript VM поддерживают WASM, что позволяет использовать код разработанные на других языках программирования, включая Rust и С++ в общей среде, совместно с кодом JavaScript.

## Модульная система: CommonJS и ESM

Модульная система помогает с решение фундаментальных проблем программной инженерии:

- обеспечивает возможность разделить код на множество файлов
- позволяет повторно использовать код в разных проектах
- скрывает детали реализации (инкапсуляция)
- позволяет управлять зависимостями

В JavaScript долгое время не было встроенной системы модулей. В браузере проблема отчасти решалась использованием разных включаемых библиотек, через тэг **Script**. Со временем появились asynchronous module definition (AMD), которая реализовывалась в рамках RequireJS и Universal Module Definition (UMD).

В Node.js тэга **Script** не было и было принято решение реализовать модульную систему прямо в коде. Это решение привело к появлению **CommonJS (CJS)**. Этот подход был поддержан и в браузерах, в частности, в проектах Browserify и [WebPack](https://webpack.js.org/).

В 2015 году был выпущен ECMAScript 6 (также называемый ECMAScript 2015), в котором появился **ESM**, или ECMA Script modules.

Считается, что со временем ESM полностью заменить CJS, но пока этого не произошло - до сих пор во многих проектах используется CJS. Однако, замечу, что многие современные packages требуют обязательного использования ESM. Один из примеров такого package [node-fetch](https://www.npmjs.com/package/node-fetch).

## Шаблон проектирования Module

Одной из самых больших проблем JavaScript является использование глобальной области видимости (global scope). Разные переменные в разных файлах могут называться одинаково и если они оказываются в глобальной области видимости это приводит к очень сложно идентифицируемым сторонним эффектам.

Чтобы минимизировать вероятность подобных ситуаций разработчики начали использовать The Module Pattern. Пример кода:

```js
const myModule = (() => {
    const privateFoo = () => {}
    const privatebar = []

    const exported = {
        publicFoo: () => {},
        publicBar: () => {}
    }
    return exported
})()

console.log(myModule)
console.log(myModule.privateFoo, module.privateBar)
```

В приведённом выше примере используется **Immediately Invoked Function Expressio (IIFE)** - когда JS разбирает завершающие круглые скобки, вся функция вызывается. Этот подход также часто именуют как **самовызывающиеся функции**.

В приведённом выше примере, внешнему коду будут доступны только экспортируемые функции publicFoo() и publicBar(), а приватные функции будут скрыты в реализации. Доступ к экспортируемым функциям будет доступен только через переменнёю myModule. Именно это и позволяет устранить коллизию в глобальном пространстве имён.

Приведённый подход лёг в основу модульной системы CommonJS.
