# Что такое Node.js. Особенности

Рекомендация к прочтению: "Node.js Design Patterns" by Mario Casciaro, Luciano Mammino.

## Философия Node.js

Значительная часть философии Node.js зафиксировал её создатель - Ryan Dahl. Зафиксирована вот здесь: https://en.wikipedia.org/wiki/List_of_software_development_philosophies

Основные идеи:

**Маленькое ядро** имеет наименьшее из возможных множество функциональных возможностей, оставляя остальное т.н. userland/userspace - экосистеме модулей, живущих вне ядра. Именно этот принцип оказывает огромное влияние на культуру Node.js, предоставляя сообществу свободу экспериментирования и быстрого развития экосистемы. Сохранение функциональности ядра на самом минимуме, является не только удобным для сопровождения продукта, но и оказывает положительное культурное влияние на эволюцию всей экосистемы.

**Маленькие модули**. Модуль имеет фундаментальное згачение в структуре кода программы. Это кирпичик для содания приложений и повторно используемых ,библиотек, называемых **packages**. Один из главных принципов дизайна в Node.js состоит в том, чтобы создавать маленькие модули, не только в терминах размера, но и в терминах **scope**. Принцип повторяет ключевой принцип философии Unix:

- Small is beautiful
- Make each program do one thing well

В npm каждый установленный package имеет своё собственное подмножество зависимостей (set of dependencies), что позволят избегать конфликтов модулей. Благодаря этому возникает беспрецендентный уровень повторного использования компонентов. Хотя такой подход кажется непрактичным из-за большого объёма зависимостей, на практике это приводит к тому, что сложно найти npm package, содержащий более 100 строк кода.

Вот почему важно сохранять маленький размер модулей:

- проще понимать и использовать
- проще тестировать и сопровождать
- отлично можно использовать и в браузере

Всё это выводит принцип Don't repeat yourself (DRY) на новый уровень.

**Small surface area**: модули в Node.js обычно имеют минимальный набор функций. Это приводит к тому, что гораздо проще понять, как использовать такой модуль.

Типовой pattern в Node.js состоит в том, что модуль реализует только одну часть функциональности, например, функцию, или конструктор, предоставляя другим модулям возможность реализовать другие особенности. Это помогает пользователям понимать, что важно, а что не очень важно в конкретной задаче.

Ещё одна характеристика Node.js состоит в том, что модули создаются для использования, а не для расширения. Тот факт, что по сути, в Node.js возможность расширения является заблокированной, кажется очень не гибким, но на практике это приводит к уменьшению прецедентов использования, упрощению реализации и споровождении, а также к увеличению usability.

**Простота и прагматизм**: ключевой принцип - Keep It Simple, Stupid (KISS).

"Simplicity is the ultimate sophistication" - Leonardo da Vinci.

## The Reactor Pattern

Ключевой компонент Node.js - **synchronous event demultiplexer** (также известный как **event notification interface**). Он следит за выполнением блокирующих операций ввода/вывода и, когда какая-нибудь из них (или несколько) завершается, управление передаётся из event demultiplexer в вызывающие его код, который обрабатывает события завершения операций ввода/вывода. После отработки событий (это называется **event loop**), управление снова передаётся demultiplexer-у, который снова отслеживает завершение не блокирующих операций ввода-вывода.

Этот подход позволяет использовать только один поток исполнения (thread) для выполнения параллельных задач, связанных с использованием I/O ресурсов. Но самое главное, этот подход позволяет реализовать модель программирования, в которой не требуется тратить вычислительные ресурсы на межпоточную синхронизацию, которая обычно обходится очень дорого.

Идея **the reactor pattern** состоит в том, что для каждой операции ввода/вывода есть обработчик, который называется **callback**. Соответственно, задача состоит в том, чтобы реагировать на завершение операции ввода/вывода передачей сообщения в связанный с этой операцией обработчик.

Связанные термины: **Event Loop** и **Event Queue**.

Главное достижение The Reactor Pattern состоит в том, что отсутствуют издержки на создание потоков, переключение между ними и на межпоточную синхронизацию.

## Libuv

В каждой операционной системе есть свой собственный механизм для event demultiplexer: **epoll** в Linux, **kqueue** в macOS и **I/O completion port** (IOCP) API в Windows. Однако, в разных операционных системах существуют фундаментальные различия в реализации операций ввода/вывода. Так, например, обычная файловая система в Linux не поддерживает non-blocking операции и, как результат, non-blocking поведение приходится реализовывать в отдельном потоке вне event loop.

Для устранения подобных различий потребовалось реализовать выcокоуровневую абстрацию для **event demultiplexer**. Именно эту задачу и решила команда Node.js разработав библиотеку **libuv**, портированную на все основные операционные системы. Пожалуй, именно эта библиотека является наиболее важной особенностью Node.js.

Рекомендуется к прочтению книга [An Introduction to libuv](https://nikhilm.github.io/uvbook/An%20Introduction%20to%20libuv.pdf) by _Nikhil Marathe_.

## Packages

Существует огромное количество packages, включая net (TCP/IP), dgram (UDP), http и https, crypto (OpenSSL).

При необходимости, мы можем подключать native code, разработанный на C/C++ посредством N-API interface.

Многие современные JavaScript VM поддерживают WASM, что позволяет использовать код разработанные на других языках программирования, включая Rust и С++ в общей среде, совместно с кодом JavaScript.

## Модульная система: CommonJS и ESM

Модульная система помогает с решение фундаментальных проблем программной инженерии:

- обеспечивает возможность разделить код на множество файлов
- позволяет повторно использовать код в разных проектах
- скрывает детали реализации (инкапсуляция)
- позволяет управлять зависимостями

В JavaScript долгое время не было встроенной системы модулей. В браузере проблема отчасти решалась использованием разных включаемых библиотек, через тэг **Script**. Со временем появились asynchronous module definition (AMD), которая реализовывалась в рамках RequireJS и Universal Module Definition (UMD).

В Node.js тэга **Script** не было и было принято решение реализовать модульную систему прямо в коде. Это решение привело к появлению **CommonJS (CJS)**. Этот подход был поддержан и в браузерах, в частности, в проектах Browserify и [WebPack](https://webpack.js.org/).

В 2015 году был выпущен ECMAScript 6 (также называемый ECMAScript 2015), в котором появился **ESM**, или ECMA Script modules.

Считается, что со временем ESM полностью заменить CJS, но пока этого не произошло - до сих пор во многих проектах используется CJS. Однако, замечу, что многие современные packages требуют обязательного использования ESM. Один из примеров такого package [node-fetch](https://www.npmjs.com/package/node-fetch).

## Шаблон проектирования Module

Одной из самых больших проблем JavaScript является использование глобальной области видимости (global scope). Разные переменные в разных файлах могут называться одинаково и если они оказываются в глобальной области видимости это приводит к очень сложно идентифицируемым сторонним эффектам.

Чтобы минимизировать вероятность подобных ситуаций разработчики начали использовать The Module Pattern. Пример кода:

```js
const myModule = (() => {
    const privateFoo = () => {}
    const privatebar = []

    const exported = {
        publicFoo: () => {},
        publicBar: () => {}
    }
    return exported
})()

console.log(myModule)
console.log(myModule.privateFoo, module.privateBar)
```

В приведённом выше примере используется **Immediately Invoked Function Expressio (IIFE)** - когда JS разбирает завершающие круглые скобки, вся функция вызывается. Этот подход также часто именуют как **самовызывающиеся функции**.

В приведённом выше примере, внешнему коду будут доступны только экспортируемые функции publicFoo() и publicBar(), а приватные функции будут скрыты в реализации. Доступ к экспортируемым функциям будет доступен только через переменную myModule. Именно это и позволяет устранить коллизию в глобальном пространстве имён.

Приведённый подход лёг в основу модульной системы CommonJS.

Важно отметить, что CommonJS является синхронным и это гарантирует заданную последовательность загрузки модулей. В момент появления CJS, был реализован и асинхронный вариант модульной системы, но его быстро запретили, т.к. функция require() возвращала не до конца проинициализированный модуль (он выполнял асинхронную инициализацию) и это приводило к массовым ошибкам и сбоям.

Node.js учитывает версии зависимостей при их загрузке и если два packages используют одну и ту же зависимость, но разных версий, то npm разместит две копии зависимости в разных node_modules, на разных уровнях иерерхии проекта. Соответственно, при загрузке зависимости в ОЗУ, при выполнении приложения, Node.js будет пытаться загрузить нужную зависимость с самого низкого уровня в дереве зависимостей и будет подниматься по дереву к его корню (root), если зависимость не будет найдена. Соответственно, для оптимизации размера занимамой памяти, следует обращать пристольное внимание на использование разных версий dependencies.

При загрузке модулей используется кэширование, что обеспечивает важные функциональные особенности: это гарантирует, что при выполнении require() для одного и того же модуля будет возвращена одна и тоже копия (instance) package. Кэширование позволяет драматически увеличить производительность приложения.

Ещё один недостаток CommonJS - в этой модульной системе возможно возникновение _циклических зависимостей_. Этот тип ошибок свойственен сложным приложениям и является трудноуловимым.

## Различные подходы определения модуля

В CommonJS модуль должен вернуть вызывающему модулю объект, через который можно обращаться к функциям и атрибутам этого модуля. Передача осуществляется через exports. Например, широко распространённый подход **named exports** может выглядеть следующим образом:

```js
exports.info = (message) => {
    console.log(`info: ${message}`);
}

exports.verbose = (message) => {
    console.log(`verbose: ${message}`);
}
```

Таким образом, через **exports** будут доступны две функции: info() и verbose(). Соотвественно, обратиться к этим функциям модуля можно следующим образом:

```js
const logger = require(`./logger`);
logger.info('Это информационное сообщение');
logger.verbose('Это многословное сообщение');
```

Существует подход, в которой модуль возвращает одну функцию - это называется **substack pattern** (автор James Halliday):

```js
module.exports = (message) => {
    console.log(`Info: ${message}`);
}
```

Вызов:

```js
const logger = require(`./logger`);
logger('Это информационное сообщение');
```

Идея подхода состоит в том, что модуль реализует единственную функцию (хотя, на практике, могут быть определены и дополнительные функции). Этот подход отражает принцип **single-responsibility (SRP)**, т.е. модуль реализует только одну функцию.

Также, модуль может возвращать определение класса, например:

```js
class Logger {
    constructor (name) {
        this.name = name;
    }

    log (message) {
        console.log(`[${this.name}] ${message}`)
    }

    info (message) {
        this.log(`info: ${message}`)
    }

    verbose (message) {
        this.verbose(`verbose: ${message}`)
    }
}

module.exports = Logger
```

Такой экспорт позволяет создать экземпляр класса:

```js
const Logger = require(`./logger`);
const dbLogger = new Logger('DB');
dbLogger.info('Это информационное сообщение');
const accessLogger = new Logger('ACCESS');
accessLogger.verbose('Это сообщение обрабатывается в другом экземпляре объекта');
```

Модификацией этого подхода является **Exporting an instance**, в котором модуль возвращает экземпляр класса, а не его описание:

```js
...
module.exports = new Logger('DEFAULT');
```

Этот подход похож на шаблон проектирования **Singleton**, он достаточно гибкий, но у него есть множество сторнних эффектов и он не рекомендуется к использованию. Гибкость проявляется, например в том, что можно создать другой экземпляр класса:

```js
const customLogger = new logger.constructor('CUSTOM');
customLogger.log(`Информационное сообщение для второго экземпляра модуля`);
```

JavaScript позволяет вноить изменения в другие модули, или в **global scope**. Этот подход называется _monkey patching_ и рассматривается как исключительно опасный. Однако, он может быть полезен, например, для mocking-а при разработке тестов. Выглядит подход таким образом:

```js
// Это реализация модуля, который выполняет patch. Файл: patcher.js
require('./logger').customMessage = function() {
    console.log('Это новый добавленный метод');
}
```

Пример применения patch-а из некоторого прикладного кода:

```js
require('./patcher');
const logger = require('./logger');
logger.customMessage();
```

В приведённом выше примере мы добавили в чужой модуль logger дополнительную функцию customMessage().

Ещё раз заметим, что в этом подходе есть side-effects, т.е. может возникнуть борьба patcher-ов с непредсказуемыми эффектами, но его реально применяют, например, он используется в package [nock](https://www.npmjs.com/package/nock).

## ESM в Node.js (новая система модулей)

По умолчанию, в Node.js используется CommonJS, а не ESM. Чтобы активировать ESM нужно либо использовать у JavaScript-файлов расширение ".mjs", либо добавить в "package.json" строку:

```json
{
    "type": "module"
}
```

Следует заметить, что в ESM вместо _plural word_ **exports**, используется _singular word_ **export**:

```js
export function log (message) {
    console.log(message);
}

export const LEVELS = {
    error: 0,
    debug: 1,
    warn: 2,
    data: 3,
    info: 4,
    verbose: 5
}
```

По умолчанию, все функции/переменные модуля для которых не указано ключевое слово **export** считаются _private_, т.е. не видимы снаружи.

Чтобы испортировать сущности, следует использовать ключевое слово **import**:

```js
import * as loggerModule from './logger.js';
console.log(loggerModule);
```

Заметим, что в случае ESM следует обязательно использовать расширение импортируемого модуля.

ESM позволяет импортировть отдельные сущности из модуля, например:

```js
import { log, Logger } from './logger.js';
const logger = new Logger('DEFAULT');
logger.log('Здравствуй МИР!');
```

Также можно назначать синонимы (aliases) для импортируемых сущностей, например:

```js
import { log as Log2 } from './logger.js';
```

Если мы хотим, чтобы модуль экспортировал одеу функцию, или описание класса, то следует использовать ключевое слово **default**:

```js
export default class Logger {
    constructor (name) {
        this.name = name;
    }

    log (message) {
        console.log(`[${this.name}] ${message}`)
    }
}
```

Импорт модуля может выглядеть следующим образом:

```js
import MyLogger from './logger.js';
const logger = new MyLogger('info');
logger.log('Hello World!');
```

Default-ный экспорт эквивалентен следующему коду:

```js
import * as loggerModule from './logger.js';
console.log(loggerModule);
```

ESM позволяет смешить _named exports_ и _default export_, что используется, например, в React.

Следует заметить, что CommonJS и ESM не обладают взаимозаменяемостью, т.е. разработчик явно должен выбрать модульную систему, которая будет использована в проекте. Так же заметим, что при выборе ESM автоматически активируется [strict-mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) для всех JS-файлов.

Если мы хотим загрузить объект из JSON-файла, это можно сделать посредством заменителя:

```js
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const data = require('./data.json');
console.log(data);
```

## Closures / Замыкания

Критически важным в JavaScript является механизм Clousres (замыкания). Почитать: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures

## Синхронность vs Асинхронность

Наличие callback-функции не говорит о том, что функция является асинхронной. Синхронная функция также может использовать callback. Признак асинхронной функции - callback вызывается после завершения обработки текущего события в Event Loop. Часто, для того, чтобы организовать асинхронность используют setTimeout():

```js
function additionAsync (a, b, callback) {
    setTimeout(() => callback(a + b), 100);
}
```

Одна из ловушек JavaScript связана со смешением асинхронного/синхронного поведения в коде. Такое смешение может приводить (и приводит) к неопределённому поведению функции. Ниже приведён пример такой функции:

```js
import { readFile } from 'fs';

const cache = new Map();

function inconsistentRead (filename, cb) {
    if (cache.has(filename)) {
        // Вызов завершается синхронно, т.к. содержимое файла уже есть в кэше
        cb(cache.get(filename));
    }
    else
    {
        // Вызывается асинхронная функция readFile(), т.е. поведение асинхронное
        readFile(filename, 'utf8', (err, data) => {
            cache.set(filename, data);
            cb(data);
        });
    }
}
```

Для большинства стандартных функций JavaScript есть синхронные аналоги. Синхронное поведение является более предсказуемым, но может приводить к потере производительности приложения, т.к. синхронные вызовы блокируют работу Event Loop. Также следует принять во внимание, что в не стандартных модулях JavaScript далеко не всегда есть синхронные аналоги асинхронным функциям.

Гарантировать асинхронность посредством отложенного выполнения (deffered execution) можно используя функцию **process.nextTick**(). Например, мы можем заменить setTimeout() в приведённом выше примере на вот такой код:

```js
process.nextTick(() => cb(cache.get(filename)));
```

Функция nextTick() работает быстрее, чем setTimeout(), т.к. не требует создания таймера. Также может быть использована функция setImmediate(), которая также отличается высокой скоростью выполнения.

## Node.js callback conventions

Существуют принципы, в соответствии с которыми следует оформлять код, в котором используются callback-функции:

- В списке параметров callback-функция указывается последней
- В списке параметров callback-функции всегда первым параметром идёт ошибка
- Уведомление об ошибке всегда передаётся через ту же callback-функцию, через которую передаётся успешный результат
- Аккуратно обрабатываются исключения, а там, где это невозможно, используется обработчик события uncaughtException

Пример API, в котором используется callback-функция:

```js
readFile(filename, [options], callback);
```

В реализации callback-функции всегда сначала обрабатывается ошибка, например:

```js
readFile('foo.txt', 'utf8', (err, date) => {
    if (err) {
        handleError(err);
    } else {
        processData(data);
    }
});
```

## The Observer pattern

В Node.js существует встроенная реализация шаблона проектирования **The Observer** (Publish/Subscribe). Вся работа осуществляется через экземпляр класса **EventEmitter**:

```js
import { EventEmitter } from 'events';
const emitter = new EventEmitter();
```

В классе реализованы следующие базовые методы:

- **on**(event, listener): метод позволяет зарегистрировать нового подписчика конкретного события
- **once**(event, listener): подписчик автоматически удаляется сразу после получения события
- **emit**(event, [arg1], [...]): метод создаёт новое событие и доставляет его подписчикам
- **removeListener**(event, listener): удаляет подписчика из списка

Пример генерации событий, посредством EventEmitter:

```js
import { EventEmitter } from 'events';
import { fileRead } from 'fs';

function findRegex (files, regex) {
    const emitter = new EventEmitter();
    for (const file of files) {
        readFile(file, 'utf8', (err, content) => {
            if (err) {
                return emitter.emit('error', err);
            }

            emitter.emit('fileread', file);
            const match = content.match(regex);
            if (match) {
                match.forEach(elem => emitter.emit('found', file, elem));
            }
        });
    }

    return emitter;
}
```

Легко увидеть, что функция findRegex() возвращает экземпляр класса EventEmitter. Через этот instance мы может оформить подписку на все три типа событий, генерируемых функцией, используя _chaining methods_:

```js
findRegex(['fileA.txt', 'fileB.json'],
    /hello \w+/g
)
    .on('fileread', file => console.log(`${file} was read`))
    .on('found', (file, match) => console.log( `Matched "${match}" in ${file}`))
    .on('error', err => console.error(`Error emitted ${err.message}`));
```

Следует заметить, что чаще всего EventEmitter не используется сам по себе, а встраивается внутрь некоторого класса, предоставляя пользователям этого класса более гибкий механизм, чем callback-функции. Гибкость, в частности, состоит в том, что можно подписываться только на интересующие пользователя события, игнорируя остальные.

Однако, использование EventEmitter потенциально приводит к _memory leaks_, т.е. утечке памяти. Утечка памяти - наиболее неприятная проблема в использовании Node.js, т.к. их (утечки) тяжело находить, но они могут приводить к падению приложения. Чтобы решить эту проблему, следует своевременно отписываться от событий, используя метод **removeListener**(). Ещё одна важная рекомендация - для получения одноразовых событий, следует использовать функцию **once**(), вметсто **on**(), хотя и в этом случае может возникнуть memory leak, если ожидаемое событие не возникнет.

Проблема утечки памяти имеет место не только в Node.js, но и в client-side applications, особенно в SPA, таких как React. Здесь следует заметить, что не смотря на то, что Redux (State Management) использует шаблон проектирования The Observer (Publish/Subscribe), его реализация не использует EventEmitter. Redux - очень компактная, прекрасно задокументированная, ООП библиотека на TypeScript, которая использует более примитивную и прямолинейную реализацию с хранением подписчиков в Map-контейнере. Чтобы минимизировать утечки памяти, метод подписки на событие - **subscribe**(), возвращает метод **unsubscribe**(), который должен быть применён в пользовательском коде в соответствии с _conventions_.

**ВАЖНЫЙ ТЕРМИН**: _shallow copy_ - быстрое копирование благодаря использованию копирования только на один уровень вниз. Для практических целей в JavaScript такого копирования оказывается вполне достаточно. В случае, если это не так, то следует использовать _deep copy_ - "глубокое" копирование объектов. Глубокое копирование является ресурсоёмкой операцией.
