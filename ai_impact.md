# Какой ИИ выбрать для разработки ПО

Колоссальное влияние ИИ на разработку программного коду в 2025-2026 годах уже не подвергается сомнению. На данный момент, вопрос актуальности применения ИИ для разработки ПО уже не стоит. Игнорирование ИИ приводит к потере конкурентоспособности.

Однако крайне важными остаётся объективная оценка ожиданий от применении ИИ и рациональный выбор модели использования ИИ.

## Опасные ожидания

В маркетинговых материалах компаний специализирующихся на внедрении ИИ приводятся оценки роста производительности кодирования в 2x, 5x, 10x раз. Однако маркетинговые материалы часто игнорируют совокупность процессов, приводящих к разработке надёжного, быстрого, легко модифицируемого решения, фокусируясь только непосредственно на генерации кода. Следствием этого являются критически завышенные ожидания, которые не трансформируются в реальные преимущества для бизнеса.

Работа по созданию программного продукта требует от программиста:

- анализа входных данных, в том числе, IT-ландшафта, в котором требуется исполнять приложения
- разработки низкоуровневых требований на основании бизнес-требований. Стоит заметить, что очень частно бизнес-требования отсутствуют и их заменяют на некоторые чаянья, описание ожиданий бизнеса (иногда на словах)
- разработки архитектуры решения (различных видов архитектуры - больше десятка)
- разработки концепции пользовательского интерфейса
- выбора инструментальных средств
- документирования технических решений
- согласования ожидаемого результата с заказчиком и с проектной командой
- планирования (формирования чёткого плана работ), включая создание сбалансированной рабочей команды
- обучение исполнителей применяемым инструментальным средствам
- разработки алгоритмов
- КОДИРОВАНИЯ (непосредственного создания программного кода)
- оценки эффективности полученного решения в сравнении с альтернативами (_benchmarking_)
- тестирования программного обеспечения, включая Unit-тестирование и автоматизированное тестирование
- устранения найденных ошибок, включая ошибки выборе архитектуры и инструментальных средств
- переработки решения по замечаниям заказчика, в том числе - пересмотр требований после ознакомления с полученным продуктом
- оптимизации решения под фактически используемый IT-ландшафт
- документирования полученного результата, включая разработку пользовательской документации и истории изменений продукта
- включения разработанной системы в pipeline автоматизированной сборки и доставки продукта потребителю (CI/CD)

В КБ ДОРС ИИ применяется для решения следующих задач:

- быстрое прототипирование с целью проверки гипотезы (архитектура, инструментальные средства, эффективность алгоритмов)
- обучение исполнителей выбранным инструментальным средствам
- разработка рутинного кода с низкой сложностью
- подготовка приложения к включению к pipeline автоматизированной сборки и развертывания
- оптимизация программного кода (как улучшения производительности, так и улучшение читаемости кода)

Следует заметить, что далеко не все из этих задач напрямую влияют на повышение скорости разработки ПО - часть влияет на качество и простоту сопровождения. При этом применение ИИ совмещается с использованием традиционных инструментов: автоматизированный анализ кода (не ИИ), точная оценка производительсности кода (benchmarking), ручная разработка Unit-тестов.

Также важно заметить, что применение ИИ далеко не всегда ускоряет разработку кода. Т.к. галлюцинаций в сгенерированном коде всё ещё очень много (есть даже специальный термин - _ai slop_), его приходится очень тщательно проверять. Некоторые недобросовестные разработчики минимизируют проверку и это проводит к быстрой деградации кодовой базы. Мы стараемся делать систематический _code review_, выявлять злоупотребления при использовании ИИ и проводить соответствующую воспитательную работу. Затраты на проверку сгенерированного ИИ кода большие.

## Выбор модели применения ИИ

Мы рассматриваем две модели использования больших языковых моделей (LLM) для разработки кода:

- Chat с LLM через терминал (CLI), или через приложение в браузере/мобильном телефоне
- Использование агентского режима (Plug-in) в среде разработки ПО. Например, Copilot в Visual Studio, [KodaCode](https://kodacode.ru/) в Visual Studio Code, или [GigaChat](https://giga.chat/) в GigaIDE

Термин "vibe-coding" относится к агентскому режиме и предполагает итеративный сценарий работы:

- программист описывает желаемый результат, уточняет способ его достижения, указывает контекст
- LLM генерирует программный код и/или управяющие команды для терминала/shell-а
- программист проверяет полученные результат и вносит корректирующие указания при переходе на следующую итерацию

Vide-coding применяется в КБ ограниченно, по двум причинам:

- требует высокой квалификации разработчика, который должен непрерывно анализировать вносимые ИИ изменения и предотвращать деградацию программного кода
- требуют дорогостоящих, мощных LLM, т.к. слабые модели очень быстро начинают галлюционировать (генерировать код содержащий критичные ошибки)

Наиболее общая рекомендация - использовать платные агрегаторы для доступа к различным современным LLM. В КБ ДОРС используются [ChadGPT.ru](https://chadgpt.ru/) и [Merlin](https://www.getmerlin.in/ru). Для экономии могут быть использованы бесплатные LLM, например, через [Duck.ai](https://duckduckgo.com/?q=DuckDuckGo+AI+Chat&ia=chat&duckai=1).

>ChadGPT.ru является типовым российским агрегатором LLM с подписочной моделью. Предлагает доступ к современным LLM: Gemini 3 Pro, Grok 4.1, GPT-5.2, Gloude 4.5 Opus, DeepSeek V3.2. Подписка на тарифном плане "Плюс" составляет 1690 руб/месяц (~900 тысяч слов на простых моделях).

В случае, если команда достаточно зрелая для того, чтобы выполнять ответственный анализ результатов работы LLM, можно экспериментировать с vibe-coding, который является более удобным для итеративных изменений кода. Основной риск vibe-coding-а состоит в том, что LLM генерируют код, который очень похож на работоспособный, но таковым не является. Программист должен сохранять критичный взгляд на сгенерированный код и не допускать даже капли лени, поскольку это приводит к быстрой деградации кода.

## Почему ИИ лучше всего генерирует код, который уже был написан 10000 раз

LLM является нейронной сетью, чаще всего основанный на архитектуре трансформеров. Он обучается на больших объёмах текста, используя методы градиентного спуска и обратного распространения ошибки.

Особенность обучения нейронных сетей состоит в том, что закрепление материала, превращение его в шаблон (pattern) происходит при возникновении множества повторов. Современные LLM умеют очень хорошо генерировать простые web-приложения на Node.js, или примеры кода машинного обучения на Python. Это происходит по тому, что именно таких примеров в публичном доступе в сети больше всего.

Если LLM оказывается недостаточно примеров, она начинает генерировать код, фактически, из случайных, слабо связанных кусков кода и это приводит к галлюцинациям.

Стоит заметить, что из условных 10000 "одинаковых" примеров кода, формируется несколько самостоятельных кластеров, поскольку существуют приципиальные отличия:

- версии инструментальных средств
- тип оптимизации: по произодительности, по лаконичности кода, по надёжности
- используемые зависимости (наборы библиотек)
- стили оформления (например, использование cameCase, или snake_case при наименовании переменных)
- этапы разработки кода: создание прототипа, или код, который вводится в промышленную эксплуатацию
- и т.д.

Соответственно, код генерируемый LLM может выбрать кластер, практически случайно. Для управления выбором кластера необходимо либо точно закладывать соотвествующие особенности в запрос, либо добаваться нужного вида кода с помощью последующих уточнений.

## Как возникает деградация программого продукта (на реальных примерах)

Ниже приведены примеры проблем, которые возникли в течение последнего месяца.

Студент генерировал код на Python для институтской задачи по курсу "цифровая лингвистика". По условиям задачи следовало выполнить векторизацию исходных документов, построив по каждому из документов вектор, содержащий частоту использования каждого слова, встречаемого в любом из документов. Затем нужно было извлечь частоту использования конкретного слова из конкретного документа.

В действительности, нам нужно было просто извлечь элемент из двухмерной матрицы:

```py
# Находим индекс столбца в матрице документов и слов
word_index = list(feature_names).index(word)
return tf_matrix[number_of_doc, word_index]
```

Вот, что сгенерировал ИИ:

```py
# Находим индекс столбца в матрице документов и слов
word_index = list(feature_names).index(word)
tf_values = tf_matrix[:, word_index].toarray().flatten()
return tf_values[number_of_doc]
```

Сразу замечу, что код сгенерированный ИИ является работоспособным, он выглядит очень профессионально, но что если попытаться оценить его эффективность?

Код извлекает весь столбец значений для этого слова по всем документам. Символ двоеточия ":" это slice, т.е. эквивалент [:], в данном случае означающий берём все строки. При этом используется только один конкретный столбец. Mетод toarray() преобразует полученный столбец в массив NumPy. Метод flatten() преобразует массив NumPy в одномерный вектор - строку, выполяя "уплощение" данных:

```py
tf_values = tf_matrix[:, word_index].toarray().flatten()
```

Далее, используя индекс документа, мы получаем частоту (TF), или IDF указанного слова в документе:

```py
return tf_values[number_of_doc]
```

Т.е. ИИ создал два новых массива и выполнил две сложных операции преобразования типов контейнеров вместо того, чтобы просто взять один элемент матрицы. Решение ИИ на два-три порядка хуже, чем код написанный программистом.

Проблема состоит в том, что если не вчитываться в код и не проверять его эффективность на постоянной основе, можно включить в промышленное решение множество супер-не эффективных алгоритмов, которые будут приводить к огромному расходу ресурсов и, косвенно, наносить коммерческий ущерб компании.

**Извлечённый урок**: сгенерированный ИИ код может выглядеть очень профессионально и даже работоспособным, но не нужно поддаваться иллюзиям, он может быть исключительно низко-эффективным.

### Пример очень быстрого, но неправильного кода

В BVS Control Center есть части кода, которые можно улучшить в части производительности. В частности, разбор HTML-документов получаемых от счётчика D820 осуществляется с помощью регулярных выражений. Для того, чтобы оценить производительность именно этого кода был использован специализированный инструмент - DotNetBenchmark. Инструмент точно оценивает время выполнения кода.

Для сравнения, с помощью ИИ был сгенерирован код, который делает тоже самое, но на низком уровне, без использования регулярных выражений.

Оригинальный код:

```csharp
private readonly string htmlExample = new(@"
	<tr valign=""middle"">
	  < td align = ""center"" width = ""60%"" colspan = ""2"" >
		< form method = ""GET"" action = ""http://192.168.1.254/ser_num/00001321.zip"" >
		  < input type = ""submit"" class=""CSS_MONO_FONT"" style=""height:50px; width:100%"" value=""N   1:      | 00001321 |        8 Banknotes"">
		</form>
	  </td>
	  <td align = ""left"" class=""CSS_MONO_FONT"" colspan=""2"">
		<a href = ""http://192.168.1.254/ser_num/00001321.zip"" >/ ser_num / 00001321.zip </ a >
		< br > 401 bytes
	  </td>
	</tr>
	<tr valign = ""middle"" >
	  < td align=""center"" width=""60%"" colspan=""2"">
		<form method = ""GET"" action=""http://192.168.1.254/ser_num/00001322.zip"">
		  <input type = ""submit"" class=""CSS_MONO_FONT"" style=""height:50px; width:100%"" value=""N   2:      | 00001322 |        5 Banknotes"">
		</form>
	  </td>
	  <td align = ""left"" class=""CSS_MONO_FONT"" colspan=""2"">
		<a href = 'http://192.168.1.254/ser_num/00001322.zip' >/ ser_num / 00001322.zip </ a >
		< br > 394 bytes
	  </td>
	</tr>
");

static readonly Regex reHref = new(@"(?inx)
	<a \s [^>]*
		href \s* = \s*
			(?<q> ['""] )
				(?<url> [^'""]+ )
			\k<q>
	[^>]* >", RegexOptions.Compiled, TimeSpan.FromMilliseconds(500));   // Ограничиваем время компиляции регулярного выражения

[Benchmark]
public void UsedRegEx()
{
    List<string> urls = new();

    // Используем регулярные выражения для того, чтобы извлечь имена файлов
    // с архивами из полученного HTML-документа
    foreach (Match match in reHref.Matches(htmlExample))
    {
        urls.Add("http://" + "192.168.1.254" + match.Groups["url"].ToString());
    }
}
```

ИИ сгенерировал следующий код (комментарии к коду добавил программист-человек):

```csharp
private readonly string baseUrl = "192.168.1.254";

[Benchmark]
public void NotUsingRegEx()
{
    List<string> urls = new();

    // Используем строковые операции для извлечения URL из href атрибутов
    int searchFrom = 0;
    while (true)
    {
        // Ищем начало тега <a
        int aTagStart = htmlExample.IndexOf("<a ", searchFrom, StringComparison.OrdinalIgnoreCase);
        if (aTagStart == -1)
            break;

        // Ищем атрибут href
        int hrefStart = htmlExample.IndexOf("href", aTagStart, StringComparison.OrdinalIgnoreCase);
        if (hrefStart == -1)
        {
            searchFrom = aTagStart + 3;
            continue;
        }

        // Ищем знак равенства
        int equalsSign = htmlExample.IndexOf('=', hrefStart);
        if (equalsSign == -1)
        {
            searchFrom = hrefStart + 4;
            continue;
        }

        // Пропускаем пробелы после знака равенства
        int quoteStart = equalsSign + 1;
        while (quoteStart < htmlExample.Length && char.IsWhiteSpace(htmlExample[quoteStart]))
            quoteStart++;

        if (quoteStart >= htmlExample.Length)
            break;

        // Определяем тип кавычки
        char quoteChar = htmlExample[quoteStart];
        if (quoteChar != '"' && quoteChar != '\'')
        {
            searchFrom = quoteStart;
            continue;
        }

        // Ищем закрывающую кавычку
        int urlStart = quoteStart + 1;
        int quoteEnd = htmlExample.IndexOf(quoteChar, urlStart);
        if (quoteEnd == -1)
        {
            searchFrom = urlStart;
            continue;
        }

        // Извлекаем URL
        string url = htmlExample.Substring(urlStart, quoteEnd - urlStart).Trim();

        // Если URL относительный, добавляем базовый адрес
        if (!url.StartsWith("http://", StringComparison.OrdinalIgnoreCase) &&
            !url.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
        {
            urls.Add($"http://{baseUrl}{url}");
        }
        else
        {
            urls.Add(url);
        }

        searchFrom = quoteEnd + 1;
    }
}
```

Результаты замера эффективности обоих результатов:

| Method           | Mean      | Error    | StdDev   | Gen0   | Gen1   | Allocated |
|----------------- |----------:|---------:|---------:|-------:|-------:|----------:|
| UsedRegEx        | 567.25 ns | 2.984 ns | 2.792 ns | 0.2813 | 0.0010 |    1768 B |
| NotUsingRegEx    | 128.94 ns | 2.572 ns | 2.962 ns | 0.0470 |      - |     296 B |

Реализация без использования RegEx даёт выигрыш в 4,75 раза, а также расходует в шесть раз меньше памяти.

Казалось бы - абсолютная победа, однако, всё не так просто. Реализация с использованием RegEx учитывает размещение атрибутов внутри тэга и работает абсолютно корректно. Этот код работает алгоритмически верно и не даёт ошибок.

Вариант сгенерированный ИИ - очень быстрый, но он сильно упрощён и работоспособен в очень ограниченных случаях. Например, код будет работать не правильно, вот в такой ситуации: 

```html
<a onclick='...'>Можно нажать</a><div href='...'>Очень странный div</div>
```

Код найдёт `<a ` в первом тэге, а `href` возьмёт из второго, который вообще не имеет никакого отношения с ссылке на пересчёт.

Подобные ошибки являются крайне сложными, т.к. на тестах всё будет работать, но возникающее в промышленной эксплуатации некорректное поведение будет практически, невозможно, объяснить.

Несколько подобных проблем могут привести к критичной деградации поведения приложения. Построить логически обоснованную модель сбоя будет практически невозможно.

**Извлечённый урок**: сгенерированный ИИ код может работать очень быстро, но за счёт нарушения фундаментальных требований к функционированию приложения. Такого рода "упрощения" крайне сложно находить, но они могут приводить к необъяснимым критичным сбоям в работе приложений.

### Мобильная версия портала сервис-партнёров

В проекте работают два программиста, назовём их Аня (front-end) и Борис (back-end). Когда Борис был о отпуске, Аня работала над адаптацией пользовательского интерфейса системы к вертикальной ориентации мобильных устройств. Ей потребовалось добавить логику - получение данных об уведомлениях из back-end и визуализировать эти уведомления на мобильных устройствах в соответствии с их возможностями. Аня разработала прекрасный дизайн, но для получения данных из back-end использовала ИИ. Сгенерированный ИИ код оказался работоспособным и изменения были допущены к промышленной эксплуатации.

Однако через некоторое время пользователя стали жаловаться на страшные тормоза, практически на всех пользовательских формах.

Как оказалось, код работы с уведомлениями для мобильных устройств работал всегда и на каждой странице, которая имела область уведомлений, выкачивал из базы данных все имеющиеся уведомления. Пока их было немного, падение производительности было незаментно, но со временем замедление работы сайта заметили все.

**Извлечённый урок**: ИИ не спасает, а только усугубляет проблемы отсутствия знаний в технологических областях. Если бы Аня не полагалась на ИИ и не стала использовать сгенерированный ИИ код, пользователи мобильных устройство не получили бы уведомлений, но промышленная система сохранила бы свою работоспособность.
