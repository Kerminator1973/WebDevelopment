# Влияние ИИ на разработку программного кода

Сначала приведу ответы на наиболее важные вопросы, а потом дам разъяснения по каждому из ответов.

Даёт ли использование ИИ значительные преимущества при разработке программного кода? ДА!

Приводит ли использование ИИ к повышению эффективности труда программиста? Несомненно!

Являются ли мощные LLM кратно более полезными, чем бесплатные LLM? ДА, являются!

Может ли применение ИИ привести к деградации программного продукта? ДА и, к сожалению, вероятность этого высока!

Может ли любой коллектив извлечь пользу от использования агентской модели LLM? НЕТ. Коллектив должен быть достаточно зрелым для использования ИИ.

Является ли коммерчески выгодным для компании оплачивать сотрудникам мощные LLM? ДА, решение простых задач может кратно ускориться.

Может ли ИИ быть эффективно использован в любом проекте? НЕТ. ИИ лучше всего работает на маленьких проектах. Чем больше технология и алгоритмы похожи на 100 тысяч таких же, уже написанных, тем выше будет качество кода сгенерированного ИИ.

## Почему ИИ лучше всего генерирует код, который уже был написан 100000 раз

LLM является нейронной сетью, чаще всего основанный на архитектуре трансформеров. Он обучается на больших объёмах текста, используя методы градиентного спуска и обратного распространения ошибки.

Особенность обучения нейронных сетей состоит в том, что закрепление материала, превращение его в шаблон (pattern) происходит при возникновении множества повторов. Современные LLM умеют очень хорошо генерировать простые web-приложения на Node.js, или примеры кода машинного обучения на Python. Это происходит по тому, что именно таких примеров в публичном доступе в сети больше всего.

Если LLM оказывается недостаточно примеров, она начинает генерировать код, фактически, из случайных, слабо связанных кусков кода и это приводит к галлюцинациям.

Стоит заметить, что из условных 100000 "одинаковых" примеров кода, формируется несколько самостоятельных кластеров, поскольку существуют приципиальные отличия:

- версии инструментальных средств
- тип оптимизации: по произодительности, по лаконичности кода, по надёжности
- используемые зависимости (наборы библиотек)
- стили оформления (например, использование cameCase, или snake_case при наименовании переменных)
- этапы разработки кода: создание прототипа, или код, который вводится в промышленную эксплуатацию
- и т.д.

Соответственно, код генерируемый LLM может выбрать кластер, практически случайно. Для управления выбором кластера необходимо либо точно закладывать соотвествующие особенности в запрос, либо добаваться нужного вида кода с помощью последующих уточнений.

## Как возникает деградация программого продукта (на реальных примерах). Возникли меньше месяца назад

Студент генерировал код на Python для институтской задачи по курсу "цифровая лингвистика". По условиям задачи следовало выполнить векторизацию исходных документов, построив по каждому из документов вектор, содержащий частоту использования каждого слова, встречаемого в любом из документов. Затем нужно было извлечь частоту использования конкретного слова из конкретного документа.

В действительности, нам нужно было просто извлечь элемент из двухмерной матрицы:

```py
# Находим индекс столбца в матрице документов и слов
word_index = list(feature_names).index(word)
return tf_matrix[number_of_doc, word_index]
```

Вот, что сгенерировал ИИ:

```py
# Находим индекс столбца в матрице документов и слов
word_index = list(feature_names).index(word)
tf_values = tf_matrix[:, word_index].toarray().flatten()
return tf_values[number_of_doc]
```

Сразу замечу, что код сгенерированный ИИ является работоспособным, он выглядит очень профессионально, но что если попытаться оценить его эффективность?

Код извлекает весь столбец значений для этого слова по всем документам. Символ двоеточия ":" это slice, т.е. эквивалент [:], в данном случае означающий берём все строки. При этом используется только один конкретный столбец. Mетод toarray() преобразует полученный столбец в массив NumPy. Метод flatten() преобразует массив NumPy в одномерный вектор - строку, выполяя "уплощение" данных:

```py
tf_values = tf_matrix[:, word_index].toarray().flatten()
```

Далее, используя индекс документа, мы получаем частоту (TF), или IDF указанного слова в документе:

```py
return tf_values[number_of_doc]
```

Т.е. ИИ создал два новых массива и выполнил две сложных операции преобразования типов контейнеров вместо того, чтобы просто взять один элемент матрицы. Решение ИИ на два-три порядка хуже, чем код написанный программистом.

Проблема состоит в том, что если не вчитываться в код и не проверять его эффективность на постоянной основе, можно включить в промышленное решение множество супер-не эффективных алгоритмов, которые будут приводить к огромному расходу ресурсов и, косвенно, наносить коммерческий ущерб компании.

**Извлечённый урок**: сгенерированный ИИ код может выглядеть очень профессионально и даже работоспособным, но не нужно поддаваться иллюзиям, он может быть исключительно низко-эффективным.

### Пример очень быстрого, но неправильного кода

В BVS Control Center есть части кода, которые можно улучшить в части производительности. В частности, разбор HTML-документов получаемых от счётчика D820 осуществляется с помощью регулярных выражений. Для того, чтобы оценить производительность именно этого кода был использован специализированный инструмент - DotNetBenchmark. Инструмент точно оценивает время выполнения кода.

Для сравнения, с помощью ИИ был сгенерирован код, который делает тоже самое, но на низком уровне, без использования регулярных выражений.

Оригинальный код:

```csharp
private readonly string htmlExample = new(@"
	<tr valign=""middle"">
	  < td align = ""center"" width = ""60%"" colspan = ""2"" >
		< form method = ""GET"" action = ""http://192.168.1.254/ser_num/00001321.zip"" >
		  < input type = ""submit"" class=""CSS_MONO_FONT"" style=""height:50px; width:100%"" value=""N   1:      | 00001321 |        8 Banknotes"">
		</form>
	  </td>
	  <td align = ""left"" class=""CSS_MONO_FONT"" colspan=""2"">
		<a href = ""http://192.168.1.254/ser_num/00001321.zip"" >/ ser_num / 00001321.zip </ a >
		< br > 401 bytes
	  </td>
	</tr>
	<tr valign = ""middle"" >
	  < td align=""center"" width=""60%"" colspan=""2"">
		<form method = ""GET"" action=""http://192.168.1.254/ser_num/00001322.zip"">
		  <input type = ""submit"" class=""CSS_MONO_FONT"" style=""height:50px; width:100%"" value=""N   2:      | 00001322 |        5 Banknotes"">
		</form>
	  </td>
	  <td align = ""left"" class=""CSS_MONO_FONT"" colspan=""2"">
		<a href = 'http://192.168.1.254/ser_num/00001322.zip' >/ ser_num / 00001322.zip </ a >
		< br > 394 bytes
	  </td>
	</tr>
");

static readonly Regex reHref = new(@"(?inx)
	<a \s [^>]*
		href \s* = \s*
			(?<q> ['""] )
				(?<url> [^'""]+ )
			\k<q>
	[^>]* >", RegexOptions.Compiled, TimeSpan.FromMilliseconds(500));   // Ограничиваем время компиляции регулярного выражения

[Benchmark]
public void UsedRegEx()
{
    List<string> urls = new();

    // Используем регулярные выражения для того, чтобы извлечь имена файлов
    // с архивами из полученного HTML-документа
    foreach (Match match in reHref.Matches(htmlExample))
    {
        urls.Add("http://" + "192.168.1.254" + match.Groups["url"].ToString());
    }
}
```

ИИ сгенерировал следующий код (комментарии к коду добавил программист-человек):

```csharp
private readonly string baseUrl = "192.168.1.254";

[Benchmark]
public void NotUsingRegEx()
{
    List<string> urls = new();

    // Используем строковые операции для извлечения URL из href атрибутов
    int searchFrom = 0;
    while (true)
    {
        // Ищем начало тега <a
        int aTagStart = htmlExample.IndexOf("<a ", searchFrom, StringComparison.OrdinalIgnoreCase);
        if (aTagStart == -1)
            break;

        // Ищем атрибут href
        int hrefStart = htmlExample.IndexOf("href", aTagStart, StringComparison.OrdinalIgnoreCase);
        if (hrefStart == -1)
        {
            searchFrom = aTagStart + 3;
            continue;
        }

        // Ищем знак равенства
        int equalsSign = htmlExample.IndexOf('=', hrefStart);
        if (equalsSign == -1)
        {
            searchFrom = hrefStart + 4;
            continue;
        }

        // Пропускаем пробелы после знака равенства
        int quoteStart = equalsSign + 1;
        while (quoteStart < htmlExample.Length && char.IsWhiteSpace(htmlExample[quoteStart]))
            quoteStart++;

        if (quoteStart >= htmlExample.Length)
            break;

        // Определяем тип кавычки
        char quoteChar = htmlExample[quoteStart];
        if (quoteChar != '"' && quoteChar != '\'')
        {
            searchFrom = quoteStart;
            continue;
        }

        // Ищем закрывающую кавычку
        int urlStart = quoteStart + 1;
        int quoteEnd = htmlExample.IndexOf(quoteChar, urlStart);
        if (quoteEnd == -1)
        {
            searchFrom = urlStart;
            continue;
        }

        // Извлекаем URL
        string url = htmlExample.Substring(urlStart, quoteEnd - urlStart).Trim();

        // Если URL относительный, добавляем базовый адрес
        if (!url.StartsWith("http://", StringComparison.OrdinalIgnoreCase) &&
            !url.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
        {
            urls.Add($"http://{baseUrl}{url}");
        }
        else
        {
            urls.Add(url);
        }

        searchFrom = quoteEnd + 1;
    }
}
```

Результаты замера эффективности обоих результатов:

| Method           | Mean      | Error    | StdDev   | Gen0   | Gen1   | Allocated |
|----------------- |----------:|---------:|---------:|-------:|-------:|----------:|
| UsedRegEx        | 567.25 ns | 2.984 ns | 2.792 ns | 0.2813 | 0.0010 |    1768 B |
| NotUsingRegEx    | 128.94 ns | 2.572 ns | 2.962 ns | 0.0470 |      - |     296 B |

Реализация без использования RegEx даёт выигрыш в 4,75 раза, а также расходует в шесть раз меньше памяти.

Казалось бы - абсолютная победа, однако, всё не так просто. Реализация с использованием RegEx учитывает размещение атрибутов внутри тэга и работает абсолютно корректно. Этот код работает алгоритмически верно и не даёт ошибок.

Вариант сгенерированный ИИ - очень быстрый, но он сильно упрощён и работоспособен в очень ограниченных случаях. Например, код будет работать не правильно, вот в такой ситуации: 

```html
<a onclick='...'>Можно нажать</a><div href='...'>Очень странный div</div>
```

Код найдёт `<a ` в первом тэге, а `href` возьмёт из второго, который вообще не имеет никакого отношения с ссылке на пересчёт.

Подобные ошибки являются крайне сложными, т.к. на тестах всё будет работать, но возникающее в промышленной эксплуатации некорректное поведение будет практически, невозможно, объяснить.

Несколько подобных проблем могут привести к критичной деградации поведения приложения. Построить логически обоснованную модель сбоя будет практически невозможно.

**Извлечённый урок**: сгенерированный ИИ код может работать очень быстро, но за счёт нарушения фундаментальных требований к функционированию приложения. Такого рода "упрощения" крайне сложно находить, но они могут приводить к необъяснимым критичным сбоям в работе приложений.

### Мобильная версия портала сервис-партнёров

В проекте работают два программиста, назовём их Аня (front-end) и Борис (back-end). Когда Борис был о отпуске, Аня работала над адаптацией пользовательского интерфейса системы к вертикальной ориентации мобильных устройств. Ей потребовалось добавить логику - получение данных об уведомлениях из back-end и визуализировать эти уведомления на мобильных устройствах в соответствии с их возможностями. Аня разработала прекрасный дизайн, но для получения данных из back-end использовала ИИ. Сгенерированный ИИ код оказался работоспособным и изменения были допущены к промышленной эксплуатации.

Однако через некоторое время пользователя стали жаловаться на страшные тормоза, практически на всех пользовательских формах.

Как оказалось, код работы с уведомлениями для мобильных устройств работал всегда и на каждой странице, которая имела область уведомлений, выкачивал из базы данных все имеющиеся уведомления. Пока их было немного, падение производительности было незаментно, но со временем замедление работы сайта заметили все.

**Извлечённый урок**: ИИ не спасает, а только усугубляет проблемы отсутствия знаний в технологических областях. Если бы Аня не полагалась на ИИ и не стала использовать сгенерированный ИИ код, пользователи мобильных устройство не получили бы уведомлений, но промышленная система сохранила бы свою работоспособность.

## Вывод

ИИ предлагает размен: быстрый выпуск прототипа на технический долг. Размер технического долга невозможно оценить.
