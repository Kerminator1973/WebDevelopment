# При публикации проекта Blazor использует Node.js

При публикации проекта, Blazor "под капотом" использует Node.js и JavaScript-код для трансляции IL-сборок в wasm-пакеты. При этом собирается не только код проекта, но и весь Runtime. Время сборки и количество ресурсов, которые при этом используются - значительные, на грани критических!

Причина, по которой используется JavaScript следующая (ChatGPT): tooling для трансляции IL в wasm разработан на TypeScript. TypeScript, как и C# - инструменты разработанные в Microsoft. В эко-системе TypeScript содержится огромная коллекция различных библиотек и инструментов, с помощью которых написать инструмент трансляции было проще всего. Т.е. более правильно говорить не о JavaScipt/Node.js, а о TypeScript и console-based Runtime (одним из вариантов которого является Node.js). Заметим, что мы имеем дело с транспайлером TypeScript -> JavaScript, результат которого осуществляет транспиляцию с IL в wasm.

Ещё одна причина использования Node.js - это развитая кросс-платформенная технология, которая работает на основных операционных системах (Windows/Linux/MacOS) "из коробки".

Важно понимать, что JavaScript - это основной механизм interop для wasm с браузером, т.е. избежать использования JavaScript в любом случае невозможно, а трансляция IL в wasm - лишь добавляет ещё один пункт в примерах совместного использования.

Для того, чтобы предотвратить повторную полную сборку проекта, необходимо использовать ключ `--no-build`:

```shell
dotnet publish --no-build
```

Этот ключ нельзя использовать безусловно, т.е. требуется добавить настройку "Полной пересборки" проекта, как опцию сборки в DevOps Pipeline. Также эта настройка может повлиять и на другие особенности DevOps Pipeline, например, придётся решать проблему с автоматической очисткой папки сборки проекта, а также выбора машины для сборки проекта.

Также возможен вариант, в котором скрипт сборки проекта (.csproj) собирает приложение без Runtime, а для сборки Runtime используется другой проект. Однако, этот вариант относится в Advanced-техникам, он сложнее в реализации и не исключает расхождения в совместимости приложения и Runtime.
