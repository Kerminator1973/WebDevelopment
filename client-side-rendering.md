# Простой, типовой подход

Предположим, что мы разрабатываем приложение для сетевого общения. Мы можем создать одну статическую страницу, которая будет состоять из файлов: "index.html", "index.css" и "index.js". Предположим, что мы используем AJAX, или WebSocket для отправки и получения новых сообщений с сервера, который использовуется нами, преимущественно, как система обмена сообщениями. При получении от сервера нового сообщения (в JavaScript-коде) мы должны оформить полученный текст в структурированный HTML-код и добавить в некоторую область отображения сообщения.

Допустим, в файле "index.html" у нас есть поле для отображения полученных сообщений:

```html
<div id="messages"></div>
```

Для **client-side rendering** часто используются вспомогательные клиентские библиотеки, например, [Mustache](https://github.com/Mustache/Mustache). Ключевая идея состоит в том, что внутри html-разметки определяется шаблон разметки и вспомогательная библиотека позволяет сформировать разметку подставив в шаблон данные.

Шаблон может выглядеть следующим образом:

```html
<script id="message-template" type="text/html">
	<div>
		<p>{{message}}</p>
	</div>
</script>
```

В шаблоне указывается позиция для вставки данных из переменной с именем message. Позиция задаётся двойными фигурными скобками: `{{...}}`.

Чтобы сгенерировать html-разметку по шаблону и добавить её к отображаемому документу может быть использован следующий код:

```javascript
const $messages = document.querySelector('#messages')
...
socket.on('message', (message) => {
	console.log(message)
	const html = Mustache.render(messageTemplate, {
		message
	})
	$messages.insertAdjacentHTML('beforeend', html)
})
```

Генерация html-разметки осуществляется вызовом функции **Mustache.render**().

Таким образом, под термином client-side rendering подразумевается, что структура отображаемого документа изменяется динамически и выполняется эта работа в браузере.

# Комплексные библиотеки и Frameworks
