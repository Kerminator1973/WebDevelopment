# JavaScript Questions&Answers

Как можно сгенерировать некоторое событие и обработать его в коде?

```js
// Создаём объект-событие
const event = new Event("build");

// Добавляем подписчика на событие
elem.addEventListener(
    "build",
    (e) => {
        /* … */
    },
    false,
);

// Доставляем событие подписчикам
elem.dispatchEvent(event);
```

Кроме класса **Event**, существуют специализированные события (например, **MouseEvent**):

```js
// Создаём событие
const event = new MouseEvent("click", {
    view: window,
    bubbles: true,
    cancelable: true,
});
// Применяем событие к конкретному элементу DOM
const cb = document.getElementById("checkbox");
const cancelled = !cb.dispatchEvent(event);
```

Если нам нужно передать какие-то данные в событии, мы можем использовать класс **CustomEvent**:

```js
const event = new CustomEvent("build", { detail: elem.dataset.time });
```

## Что такое microtasks и macrotasks

Термины относятся к Event Loop и очереди сообщений. Событие может возникнуть в момент, когда движок JS выполняет некоторые действия, например, обрабатывает некоторое событие. JavaScript не сможет сразу же начать обрабатывать новое событие и поместит его в очередь событий. Когда движок JS выполнит текущую задачу, он обратиться в очередь из возьмёт из неё одну из задач.

С целью оптимизации процесса обработки событий из очереди сообщений, было введено два типа задач:

- макро-задачи - связаны с обработкой действий пользователя в браузере: перемещение курсора мыши, нажатие кнопок, и т.д.
- микро-задачи - действия, связанные в блокирующий I/O и Promises

Движок JS сначала выполняет все микро-задачи, а затем уже выполняет макро-задачи.

## Управление загрузкой JavaScript-а

Если необходимо загрузить js-код после того, как HTML-файл загрузиться целиком, следует использовать атрибут **defer**:

```html
<script src="..." defer></script>
```

Подобная ситуация возникает в том случае, если JavaScript-файл начинает искать DOM-элементы сразу же после своей загрузки. Если js-файл загрузится раньше, чем HTML, то функции поиска DOM-элементов не будут работать корректно.

Атрибут defer является альтернативой размещения директивы загрузки js-файлов в конце документа.

Ещё один полезный атрибут - `type="module"`. Этот атрибут позволяет указать, что следует использовать модульную систему JavaScript, т.е. импортировать js-файлы из других js-файлов, используя директиву `import`.

## Определение класса с конструктором

Классы в JavaScript - не самая популярная конструкция, но и они вполне могут быть полезны. Пример определения класса:

```js
class Person {
    constructor(name, age, email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    introduce() {
        return `Hi, my name is ${this.name} and I'm ${this.age} years old.`;
    }
}
```

В английском языке класс часто называют "blueprint", т.е. "чертёж", по которому создают экземпляр класса - instance. Делается это с помощью ключевого слова new:

```js
const john = new Person("John Doe", 30, "john@example.com");
console.log(john.introduce());
```

Ключевое слово **this** имеет большое значение в JavaScript - оно создаёт контекст. Если мы используем this внутри функции, то this определяет в качестве контекста класс, которому принадлежит функция, или другую функцию, внутри которой вложена функция, использующая this.

Заметим, что использование this достаточно не однозначая вещь. Предположим, что у нас есть некоторый класс:

```js
class Example {
    constructor() {
        this.value = 42;
    }

    regularMethod() {
        console.log(this.value); // Работает как и ожидается, `this` ссылается на экземпляр класса
    }

    problemMethod() {
        setTimeout(function() {
            console.log(this.value); // Ошибка, см. описание ниже
        }, 1000);
    }
}
```

Поскольку `this` используется из callback-функции, он НЕ связан с экземпляром класса. Вместо эого `this` ссылается на глобальный контекс, или, в **strict mode** будет установлен в **undefined**.

При использовании стрелочных функций доступ к контексту через `this` работает корректно, `this` автоматически ссылается на окружающий функцию контекс, которым является экземпляр класса:

```js
class Example {
    constructor() {
        this.value = 42;
    }

    arrowMethod() {
        setTimeout(() => {
            console.log(this.value); // Работает корректно
        }, 1000);
    }

    arrowMethodDefinition = () => {
        console.log(this.value); // Работает корректно, лексически привязан к экземпляру класса
    }
}
```
