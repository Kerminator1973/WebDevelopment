# Почему нельзя создать только один универсальный язык программирования

Язык программирования является набором правил, позволяющих описать реализацию концепцию типового приложения. Различаются именно концепции типового приложения, определяющие набор применяемых шаблонов (моделей).

К основным шаблонам (моделям) можно отнести:

- модель управления памятью (ручная, сборка мусора)
- модель владения объектами (свободная, явное владение)
- модель многопоточности
- поддержка парадигмы ООП
- поддержка обобщённого программирования
- модель интеграции с библиотеками, разработанными на других языках программирования
- полнота реализации runtime. Например, в C++ runtime минимальный, что облегчает перенос приложений на другие платформы. В C\# runtime полный, что удобно с точки зрения разработки прикладного кода
- типизация (строгая, слабая, не явная - имеется ввиду выведение типа)
- компактность Runtime. Компактный Runtime можно использовать на микроконтроллерах (MicroPython), либо в облачных лямбда-функциях

Не основные, но важные шаблоны это:

- разнообразие синтаксического сахара
- dependency injection / внедрение зависимостей
- система управления модулями (например: cargo, npm, NuGet, никакая)
- streams - API, которые позволяют выполнять полный цикл обработки блока данных (chunk), без необходимости сохранения всех результатов работы очередного этапа в буфере
- Zero Cost Abstractions (это особенность C++, в которой акциент сделан именно на том, что высокоуровневый код работает с такой же производительностью, как и низкоуровневый)
- возможность изменения полей объекта в стороннем коде. Например, в C++ можно запретить изменение объекта передаваемого в некоторый класс используя модификатор **const**, а в JavaScript этого сделать нельзя и для защиты полей объекта приходится использовать _defensive copy_, т.е. передавать во "враждебный" код не сам объект, а лишь его копию, которая будет уничтожена после вызова

Выбор варианта реализации модели является критически влияет на язык программирование и его годность для разработки конкретных типов приложений. Лучшего варианта не существует, т.к. для некоторых приложений прекрасно подходит сбощик мусора, но для других приложений его использование может быть недопустимым.

## Си/C++

Управление выделением памяти "вручную", через менеджер памяти. Модель владения объектами - свободная. Многопоточность уровня операционной системы.

В Си не поддерживается ни ООП, а обобщённое программирование. В C++ поддерживаются оба.

Строгая типизация.

## Rust

Управление памятью "вручную", но ввиду поддержки модели явного владения, программист не обязан управлять выделением памяти.

Фокус языка смещён именно на *objects ownership*.

## JavaScript

Автоматический сборщик мусора.

Пользовательский код однопоточный, но Runtime - многопоточный, уровня операционной системы. Пользовательская многопоточность значительно снижает сложность разработки concurrency-кода, а асинхронное выполнение обеспечивает высокую утилизацию вычислительных ресурсов. Однако, на JavaScript крайне сложно поддерживать аппаратную многопоточность на уровне пользовательского кода.

ООП поддержан слабо. Обобщённого кода, практически нет.

## C\#

Автоматическая сборка мусора.

Многопоточность - уровня операционной системы, а также т.н. *green threads* (Tasks) уровня Runtime.

ООП и обобщённое программирование поддерживаются, но на минималках.

## Java

Практически то же самое, что и C\#, но с более консервативным синтаксисом.

## Python

Автоматическая сборка мусора.

Пользовательский код однопоточный. Ownership - не поддерживается.

ООП - зачаточное состояние. Обобщённое программирование не поддерживается.

Слабая типизация.

Однако, цель Python в другом - он использует внешние библиотеки, наиболее важные из которых разработаны на C++ (см. Boost.Python). Это позволяет разрабатывать очень простой пользовательский код, который использует очень быстрые библиотеки. Пример: Python и Machine Learning.
