# Микросервисная архитектура, курс на Netology

По мнению автора курса "Проектирование системы. Основы организации программных решений" (Михаил Триполитов, ПАО Открытие ?), макросервисная архитектура позволяет решать практические задачи в условиях, когда невозможно создать детальный план работ и отсутствует подробная документация о том, что нужно сделать. В подобной ситуации следует сформировать набор ограничений и принципов которые позволят развивать систему по мере получения новых знаний.

Основной аспект - необходимо особенно внимательно работать над тем, что находится на границах контекста задач, решаемых разными командами в рамках одной информационной системы.

Буквально на первой же лекции начинается ересь о том, что "_да, по классике каждая команда сама определяет технологический стек, удобный для разработки сервиса, но компании это не удобно и по этой причине, следует ограничивать технологический стек_". Даже не хочу комментировать утверждения о том, что "_если разработчики будут использовать удобный им продукт, то они не будут эффективно накапливать общекорпоративную экспертизу_".

Автор пересказывает подходы применяемые в "зелёном банке" под названием "микросервисная архитектура", повторяя все ранее озвученные заблуждения и манипуляции.

Тут я хотел бы вернуться к этим самым противоречениям, для иллюстрации. В технологическом стеке С. основной упор делается на эко-систему Java (актуально на 2024 г.). Эко-система зрелая, в ней много качественных инструментов и она доказала свою жизнеспособность в Enterprise. Однако для решения задч динамического горизонтального масштабирования этот инструмент не очень хорош, т.к. он медленно стартует в контейнерах. Для задач быстрого старта в контейнерах гораздо лучше подходят Go, Rust и C++. Однако в технологическом стеке "зелёных" нет ни Go, ни Rust. Т.е. они выбирают в качестве основы для разработки микросервисной архитектуры инструмент, который реально прекрасно работает в монолите, но не в условиях динамически изменяемой нагрузки.

>Для контроля, промпт для Алиса.ПРО: "_Я планирую разработать сложное распределённое приложение, в котором будет нагрузка будет сильно изменяться в течение рабочего дня. Я планирую использовать Kubernetes для поднятия новых instances моего приложения. Для меня критично время запуска контейнера. Если сравнивать популярные языки программирования, какие из низ были бы наиболее эффективными для решения задачи запуска и остановки контейнеров?_"
>
>Для разработки распределённого приложения с динамической нагрузкой в Kubernetes, где критично время запуска контейнеров, стоит обратить внимание на языки программирования, обеспечивающие быструю компиляцию, минимальный размер исполняемого кода и эффективное управление ресурсами. Среди популярных языков особенно подходят Go и Rust. Также можно рассмотреть C++, но он требует более глубокого погружения в системное программирование.
>
>Далее Алиса приводит доводы в пользу Golang, Rust и C++.
>
>Что касается Java, то Алиса выражает солидарное со мной мнение: "_В целом, экосистема Java остаётся мощной и востребованной, особенно в корпоративных средах, где важна стабильность, зрелость инструментов и обширная база готовых решений. Однако для проектов, где критична максимальная производительность и скорость запуска, могут быть предпочтительны более лёгкие языки или подходы._"
 
Заканчивается первая лекция словами о том, что стандартизация очень важна. Ok.

## Предметно-ориентированное проектирование

Важная часть лекций - рассказ о предметно-ориентированном проектировании.

Декларируется правило: один контекст, один сервис, одна команда. Контекс - это некоторое целостное понятие, например: витрина, рассчёт комиссии, и т.д. Также: отдельный репозитарий, отдельная база данных.

Декомпозицию сервисов предлагается делать исходя из частоты изменений. Если есть какой-то функционал, который постоянно изменяется, то его имеет смысл выделить в отдельный сервис.

Другие причны выделение функционала в отдельный сервис: масштабирование, независимость (имеется ввиду расход ресурсов) и сложность.

Цитата: "Хороший сервис должен обладать слабой связанностью и сильным зацеплением".

## Оркестрация и хореография

**Оркестрация** — это централизованный подход к управлению взаимодействием микросервисов. В системе есть специальный компонент — оркестратор (своего рода "дирижёр"), который:

- владеет всей логикой бизнес‑процесса
- явно управляет потоком выполнения, диктуя микросервисам, что и когда делать
- хранит контекст (состояние) текущего выполнения процесса (например, ID заказа, текущий шаг)
- координирует вызовы других сервисов
- отвечает за обработку ошибок и распределённых транзакций (часто с использованием Saga‑паттерна)

**Хореография** — это децентрализованный подход, где микросервисы взаимодействуют напрямую, обмениваясь событиями. Нет единого контроллера: каждый сервис автономно решает, как реагировать на полученные события.

Ключевые принципы:

- децентрализованное управление
- слабая связанность сервисов (знают только о событиях, на которые подписаны)
- управляемость событиями (состояние процесса определяется потоком событий)

Автор курса рекомендует использовать оркестрацию, т.к. она более обозримая, проще контролировать ошибки возникающие в системе.

## Протоколы

Автор курса акцентирует внимание на REST. Однако он замечает, что у REST есть ограничения и делает ссылку на GraphQL.

Для асинхронного взаимодействий предлагается использовать RabbitMQ и Kafka.

**API Gateway** — это служба (прокси‑сервер), которая служит единой точкой входа для клиентских запросов к микросервисам приложения. Она принимает запросы от клиентов (веб‑приложений, мобильных приложений и т. д.), обрабатывает их и направляет к нужным внутренним сервисам, а затем возвращает ответ клиенту. Недостаток - дополнительная задержка при маршрутизации на прикладном уровне. Однако **API Gateway** довольно популярны в микросервисной архитектуре.

## Версионирование

Важная поддержка нескольких версий контрактов для совместимости.

Критически важно управлять версиями сервисов единообразно. Автор предлагает использовать схему SemVer:

```
Major.Minor.Patch
```

- Major: обратно несовместимые изменения
- Minor: добавлена новая функциональность, изменения обратно совместимы
- Patch: исправлены ошибки в существующей функциональности

## Горизонтальное масштабирование - 12 факторов

- весь код сервиса должен быть в одном репозитории. Deployment только из репозитория
- явно объявляется и изолируйте зависимости (использование файла manifest)
- конфигурация должна сохранятся в среде исполнения (не в коде)
- сторонние службы (_backing services_) - подключаемые ресурсы. Настройки подключения должны хранится в конфигурациях (не в коде)
- строгое разделение стадий (stages): сборка, release (подготовка данных к поставке; сборка + конфигурация), выполнение
- следует запускать сервис в виде процессов но без сохранения состояния (_stateless_)
- следует использовать привязку портов (_Port Binding_)
- масштабируйте приложение посредством запуска дополнительных процессов
- утилизируемость (Disposability). Максимизируйте надёжность с помощью быстрого запуска и корректного завершения работы
- держите конфигурации разработки (development), промежуточного развертывания (staging) и рабочего развертывания (production) максимально похожими
- журналирование. Рассматривайте журнал как поток событий. Сервис пишет свои логи в stdout. Специализированное ПО перехватывает stdout и сохраняет в централизованную систему
- выполняйте задачи администрирования в виде отдельных процессов. Примеры: миграция баз данных

## CI/CD

Непрерывная интеграция - при любом commit-е приложение собирается и автоматически тестируется. Развертывание возможно только для приложений прошедших проверку.

Система автоматизированной сборки обеспечивает повторяемость сборки.

Стратегии развертывания:

- Recreate - все instances на стенде меняются со старой на новую. Требуется полная установка всех сервисов
- Rolling deployment - последовательно: останавливается один instance и запускается один новый. Простота реализации и простота отката
- Blue Green deployment - два стенда - один работает, второй разворачивается. Когда второй развернут, он перехватывает управление, а первый уходит в stand-by. Проблема: половина машин стоит в stand-by. Но зато это самый низко-рисковый вариант работы системы
- Canary deployment - постепенно переключение instances на новую версию: 1% -> 10% -> 70% -> 100%
- A/B testing - это подход для экспериментирования. На одном и том же стенде загружаются разные варианты решения проблемы (разные реализации) на ограниченное время. По результатам принимается решение о том, какой подход лучше работает
- Shadow testing - использование реального трафика в дублирующую систему, для её тестирования. Реальные боевой трафик используется для полноценного тестирования новой системы. При этом на пользователя это никак не влияет, т.к. во время тестирования пользователей использует промышленная система.

В лекции есть отличная таблица, посредством которой визуализируются особенности каждого из подходов.

## Тестирование

**Пирамида тестирования** - устойчивый термин, которй показывет какие тесты используются в системе.

Медленные -> End to End - Service - Unit Test <- Быстрые

Дорогие -> End to End - Service - Unit Test <- Дешевые

End to End тесты - тестирование осуществляет извне другая система.

Unit Test-ы - максимально дешевые и быстрые, поскольку пишутся разработчиками и покрывают отдельные функции в коде. Service - полная проверка изолированного теста.

## Безопасность

Лекция: межсервисная аутентификация и авторизация. Двухфакторная аутентификация.

**Single Sign On** - подход, в котором пользователь аутентифицируется один раз и получает доступ ко множествам сервисов. Существуют множество разных подходов, начиная с доменной аутентификации и заканчивая OpenID.

Для межсерверной аутентификации и авторизации используются:

- без аутентификации
- клиентские сертификаты
- пользовательские токены
- HMAC
- простая HTTP-авторизация
- API Keys
- OAuth2

После авторизации пользователя в схеме с SSO генерируется пользовательский токен, в котором есть права и привелегии пользователя в системе. Наиболее популярный подход - JWT.

При использование Basic HTTP Authentication необходимо закрывать соединение https.

OAuth2 - популярный подход, т.к. есть очень много серверов, реализующих функционал OAuth2.

Наилучший вариант - использование клиентского сертификата.

HMAC - макирование. Нужен доверенный канал. Походе на Remote Key Loading. Простой в реализации, быстрый. Не защищён от повторной отправки запроса.

API Keys - одновременно и идентификатор пользователя, и пароль. Необходимо использовать https. Низкий уровень безопасности. Активно используется провайдерами облачных сервисов.

Рекомендуется совмещать TLS и HMAC.

## Мониторинг

Лекция: метрики, логи и трассировка.

Для микросервисной архитектуры необходимо использовать централизованную систему логирования.

Часто ставят локально демона: **logstash**, **vector**, который собирает stdout и пересылает на сервер.

ElasticSearch: часто используется для анализа логов.

Kibana: консоль для формирования запросов к системе логирования.

Распределённая трассировка: Jaeger Agent -> Jaeger Collector -> Cassandra <- Jaeger UI

## Хрупкость системы

Чем больше сервисов - тем больше точек отказа.

Система должна быть толерантной к отказам.

Шаблоны повышения надёжности системы:

- Максимальное время ожидания - Timeout
- Повтор запроса - Retry
- Прерыватели цепи - Circuit Breaker
- Перегородки - Bulkhead
- Ограничитель количества запросов - Rate Limiter
- Изоляция
- Идемпотентность
