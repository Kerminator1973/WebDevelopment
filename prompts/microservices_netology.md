# Микросервисная архитектура, курс на Netology

По мнению автора курса "Проектирование системы. Основы организации программных решений", макросервисная архитектура позволяет решать практические задачи в условиях, когда невозможно создать детальный план работ и отсутствует подробная документация о том, что нужно сделать. В подобной ситуации следует сформировать набор ограничений и принципов которые позволят развивать систему по мере получения новых знаний.

Основной аспект - необходимо особенно внимательно работать над тем, что находится на границах контекста задач, решаемых разными командами в рамках одной информационной системы.

Буквально на первой же лекции начинается ересь о том, что "_да, по классике каждая команда сама определяет технологический стек, удобный для разработки сервиса, но компании это не удобно и по этой причине, следует ограничивать технологический стек_". Даже не хочу комментировать утверждения о том, что "_если разработчики будут использовать удобный им продукт, то они не будут эффективно накапливать общекорпоративную экспертизу_".

Автор пересказывает подходы применяемые в "зелёном банке" под названием "микросервисная архитектура", повторяя все ранее озвученные заблуждения и манипуляции.

Тут я хотел бы вернуться к этим самым противоречениям, для иллюстрации. В технологическом стеке С. основной упор делается на эко-систему Java (актуально на 2024 г.). Эко-система зрелая, в ней много качественных инструментов и она доказала свою жизнеспособность в Enterprise. Однако для решения задч динамического горизонтального масштабирования этот инструмент не очень хорош, т.к. он медленно стартует в контейнерах. Для задач быстрого старта в контейнерах гораздо лучше подходят Go, Rust и C++. Однако в технологическом стеке "зелёных" нет ни Go, ни Rust. Т.е. они выбирают в качестве основы для разработки микросервисной архитектуры инструмент, который реально прекрасно работает в монолите, но не в условиях динамически изменяемой нагрузки.

>Для контроля, промпт для Алиса.ПРО: "_Я планирую разработать сложное распределённое приложение, в котором будет нагрузка будет сильно изменяться в течение рабочего дня. Я планирую использовать Kubernetes для поднятия новых instances моего приложения. Для меня критично время запуска контейнера. Если сравнивать популярные языки программирования, какие из низ были бы наиболее эффективными для решения задачи запуска и остановки контейнеров?_"
>
>Для разработки распределённого приложения с динамической нагрузкой в Kubernetes, где критично время запуска контейнеров, стоит обратить внимание на языки программирования, обеспечивающие быструю компиляцию, минимальный размер исполняемого кода и эффективное управление ресурсами. Среди популярных языков особенно подходят Go и Rust. Также можно рассмотреть C++, но он требует более глубокого погружения в системное программирование.
>
>Далее Алиса приводит доводы в пользу Golang, Rust и C++.
>
>Что касается Java, то Алиса выражает солидарное со мной мнение: "_В целом, экосистема Java остаётся мощной и востребованной, особенно в корпоративных средах, где важна стабильность, зрелость инструментов и обширная база готовых решений. Однако для проектов, где критична максимальная производительность и скорость запуска, могут быть предпочтительны более лёгкие языки или подходы._"
 
Заканчивается первая лекция словами о том, что стандартизация очень важна. Ok.

## Предметно-ориентированное проектирование

Важная часть лекций - рассказ о предметно-ориентированном проектировании.

Декларируется правило: один контекст, один сервис, одна команда. Контекс - это некоторое целостное понятие, например: витрина, рассчёт комиссии, и т.д. Также: отдельный репозитарий, отдельная база данных.

Декомпозицию сервисов предлагается делать исходя из частоты изменений. Если есть какой-то функционал, который постоянно изменяется, то его имеет смысл выделить в отдельный сервис.

Другие причны выделение функционала в отдельный сервис: масштабирование, независимость (имеется ввиду расход ресурсов) и сложность.

Цитата: "Хороший сервис должен обладать слабой связанностью и сильным зацеплением".
