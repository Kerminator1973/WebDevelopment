# Разработка web-приложений с использованием Blazor

...

## Создание первого приложения

Инструкция базируется на [статье на сатйе MIcrosoft.NET](https://dotnet.microsoft.com/en-us/learn/aspnet/blazor-tutorial/create).

Для генерации boilerplate-кода можно использовать шаблоны приложений встроенных в Visual Studio. Начать имеет смысл с шаблона "Blazor Web App", который поддерживает server-side rendering и клиентское взаимодействие. Также существует шаблон "Blazor Web Assembly App Empty", которое содержит только клиентское приложение, хостинг которого выполняется средствами ASP.NET Core App.

В форме "Additional Information" следует убрать кнопку "Do not use top-level statements".

В соответствии с шаблоном генерируется Server-Side приложение на ASP.NET Core - файл "Program.cs". В этом файле запускается ряд сервисов, включая web-сервер для статических файлов, AntiForgery и включается mapping Blazor-компонентов.

В папке "Components" будет доступно несколько razor-pages (server-side). В частности, страница App.razor загружает стили (включая bootstrap) и ключевой скрипт управления web-приложением "blazor.web.js":

```js
<body>
    <Routes />
    <script src="_framework/blazor.web.js"></script>
</body>
```

Здесь есть существенное ограничение - если основываться на статье [Введение в Blazor с сайта Метанит](https://metanit.com/sharp/blazor/1.1.php), _web assembly_ используется только для загрузки .NET и необходимых сборок. Как следствие, появляются как уникальные свойства, так и существенные недостатки. Уникальные свойства:

- Загруженное приложение может в дальнейшем работать без подключения к Интернет
- Компилятор .NET создаёт native code, обладающий очень высокой производительностью
- Можно использовать packages, разработанные на C#, который доступно очень много

Недостатки так же очень существенные:

- Если на машине не установлен .NET, то его нужно загрузить при первой загрузке страницы
- Появляется очевидная зависимость рабочего места (компьютера) от экосистемы Microsoft.NET
- Ряд аппаратных платформ не совместим с Microsoft.NET. Например, это процессоры с архитектурой Эльбрус (VLIW-архитектура), Loongson (на базе архитектуры MIPS)

Ориентировочно, базовый [размер загрузки приложения .NET - 6.72 Мб](https://www.reddit.com/r/Blazor/comments/kx8a17/whats_the_size_of_mb_downloaded_by_the_browser/). Такой размер достигается благодаря использованию trimmer-а - приложения, которое исключает из состава приложения не нужные ему зависимости. Т.е. чем больше у приложения зависимостей, тем больший объём данных оно будет скачивать с сервера. Следует заметить, что trimmer [не всегда может срабатывать корректно](https://learn.microsoft.com/en-us/aspnet/core/blazor/host-and-deploy/configure-trimmer?view=aspnetcore-6.0) - он не учитывает случаев использования Reflection и динамические типы. В этом случае, необходимо давать подсказки триммеру, как в сборке, так и в самом проекте. Рекомендуется ознакомиться с видео [Introducing Blazor: Razor Components | ASP.NET Core 101 - 10 of 13](https://www.youtube.com/watch?v=R23v4lgHYQI&ab_channel=dotnet).

Замеры трафика приложений из коллекции [Grid.Blazor](https://github.com/gustavnavar/Grid.Blazor) позволяют утверждать, что для реального приложения объём - 20 Мб.

Важным следствием применения триммера является тот факт, что каждое приложение загружает необходимые ему packages и runtime.

Также рекомендуется ознакомиться с обсуждением на [Blazor wasm size and load time is the worst and biggest problem ever and should be the #1 priority](https://github.com/dotnet/aspnetcore/issues/41909).

Стоит заметить, что [Blazor Server не загружает Microsoft.NET](https://learn.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-8.0) и может работать с браузерами, не поддерживающими Web Assembly. Однако, в этом варианте значительно повышается латентность системы, т.к. любое изменение на клиенте транслируется на сервер и выполняет [частичный?] рендеринг страницы.

Файл "Routes.razor" содержит тэги для запуска навигационной системы с использованием Blazor Web Assembly:

```js
<Router AppAssembly="@typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="@routeData" DefaultLayout="@typeof(Layout.MainLayout)" />
        <FocusOnNavigate RouteData="@routeData" Selector="h1" />
    </Found>
</Router>
```

Так же в папке "Components" есть две подпапки: "Layout" и "Pages". Подпапка "Layout" содержит разметку основной формы (MainLayout.razor) и навигационную панель (NavMenu.razor). В подпапке "Pages" находится реализация страниц, по которым можно переходить посредством навигационной системы Blazor.

Типовой пример страницы:

```csharp
@page "/counter"
@rendermode InteractiveServer

<PageTitle>Counter</PageTitle>

<h1>Counter</h1>

<p role="status">Current count: @currentCount</p>

<button class="btn btn-primary" @onclick="IncrementCount">Click me</button>

@code {
    private int currentCount = 0;

    private void IncrementCount()
    {
        currentCount++;
    }
}
```

Можно увидеть, что в файле есть часть, содержащая код (`@code{}`) и часть, содержащая верстку. Макросы @page и @rendermode определяют идентификатор страницы для использования в навигационной системе и режим работы - InteractiveServer.

В случае использования server-side rendering, при возникновении событий на стороне клиента, они транслируются на сервер посредством библиотеки SignalR (WebSockets). В общем случае, обмен данными быстрый, но в информационных системах с ограничением количества одновременно открытых соединений и высокой латентностью сети, Blazor-приложения могут испытывать серьёзные проблемы.

Следует сразу заметить, что при использовании профиля "https", современные версии Chrome не дадут запустить его без доверенного сертификата. В этом варианте основным браузером для разработки приложения станет Microsoft Edge. Однако, если запустить приложение из под профила "http", то Chrome не будет блокировать работу приложения на localhost. 

## Добавлить ещё одну кнопку и обработчик

Предположим, что нам нужно добавить ещё одну кнопку на форму "Counter" (приведённую выше). Для этого мы оперделяем кнопку в верстке:

```html
<button class="btn btn-primary" @onclick="DecrementCount">Decrement</button>
```

Обработчик нажатия на кнопку будет называться DecrementCount и выглядеть в коде он будет так:

```csharp
@code {
    private void DecrementCount()
    {
        currentCount--;
    }
}
```

## Первые впечатления

По структуре проекта, похоже на React с TypeScript. Однако пока не понятно, как реализовывать State Management/хуки, функционал, который является _the most challengable_ в React.

Не очень нравится, что Microsoft пытается сдвигать фокус на Server-Side. Понятно, зачем эту нужно Microsoft (чтобы продавать Azure). Программистам, возможно, это было бы удобно, чтобы не реализовывать AJAX-взаимодействие в SPA: есть верстка выполняется на сервере (частичная верстка), то AJAX оказывается спрятан внутри Blazor (он существует, но не явно). Пока не понятно, какие преимущества даёт Blazor для режима SPA, т.е. без Server-Side Rendering.

Необходимость загрузки .NET на целевую платформу может быть проблемой, т.к. далеко не все пользователи имеют быстрый интернет без ограничений трафика. Трафик в РФ становится всё дороже. Например, Билайн предлагает пакет на 15Гб за 350 рублей. Ситуация выглядит так, что Blazor - это нишевая технология, которую можно эффективно применить в Enterprise-приложениях.

На третий день знакомства с технологией, создалось впечатление, что Blazor Web Assembly - это не про SPA, а более крутая альтернатива Electron. Т.е. это Offline-приложение с использованием web-технологий, загружаемое через браузер.
