# Webpack 4: Beyond the Basics by Lawrence Whiteside

Пример использования WebPack для Bundling-а Web-приложения выполнялся по мере прохождения курса на [Udemy](https://www.udemy.com/course/webpack-beyond-the-basics/learn/lecture/8445444?start=0#overview).

Что такое **WebPack**? По сути, это система сборки web-приложений. Разработчик устанавливает необходимые Plug-ins и разрабатывает конфигурационные файлы "webpack.dev.js"/"webpack.prod.js" (имена могут быть любыми), в которых указывается какие Plug-ins и как нужно применять. Вся магия сосредоточена в Plug-Ins, которые позволяют, например:

1. Использовать расширенный синтаксис JavaScript (Babel), или применять TypeScript
2. Использовать расширенный синтаксис CSS (SASS, LESS, Stylus)
3. Обеспечивать совместимость со старыми браузерами посредством polyfills
4. Применять Hot Loader-ы в режиме разработки кода
5. Выполнять минификацию, bundling, и т.д.
6. Добавлять сжатие данных посредством алгоритмов **gzip** и **Brotli**

Загрузка зависимостей (packages): `npm install`

Запуск Developer Server (webpack-dev-server): `npm run start`. Эта команда включена (вручную) в **package.json**.

Если сборка прошла успешно, то можно перейти в браузер и посмотреть результат: `http://localhost:8080/`

Сборка bundle осуществляется командой: `npm run start`

# Коротко о терминах

**Transpiler** - утилита, которая конвертирует исходный текст из одной версии языка программирования (или другого языка) в другой язык. Например, transplier может привести TypeScript к ES6, или ES2017 к ES6.

[Babel](https://babeljs.io/) - один из наиболее популярных transpiler-ов. В частности, используется в [React](https://ru.reactjs.org/)

**Polyfill** - код, который заменяется некоторую функциональную возможность современной версии языка программирования, на эквивалентную реализацию на более ранных языках программирования. Например, можно заменить arrow functions из ES2017 на эквивалентый, но более медленный и многословный код на ES6. Чаще всего, polyfill распространяется на конкретную возможность.

**Presets** - наборы polyfills, реализующий некоторое подмножество языка программирования. Задача - упростить установку и настройку polyfills

[Webpack Dev Server](https://webpack.js.org/configuration/dev-server/) - сервер для отладки приложений с использованием Webpack. Базируется на Express Cocoa и его можно воссоздать используя Express с несколькими дополнительными **middlewares**.

[Nodemon](https://www.npmjs.com/package/nodemon) - консольная утилита, которая отслеживает изменения в js-файлах и автоматически пересобирает проект, если находит какие-либо изменения в нём.

**HTML Preprocessor** - вспомогательная библиотека (package), которая осуществляет обработку шаблона страницы, содержащей HTML и макросы. Значения макросов, чаще всего устанавливаются в JavaScript-коде (отдельный словарь содержит значения макросов шаблона). Примерами HTML Preprocessors являются [EJS](https://ejs.co/), [Pug](https://pugjs.org/api/getting-started.html) (ранее Jade), [Slim](http://slim-lang.com/about.html), [Handlebars.js](https://handlebarsjs.com/), [HAML](http://haml.info/). HTML препроцессоры также называют *шаблонизаторами*.

**CSS Preprocessor** - вспомогательная библиотека (package), расширяющая возможности каскадных таблиц CSS: использование вложенных блоков CSS, переменных (например: `@gray: #444`), импорта вложенных каскадных таблиц (например: `@import ./profile`), добавление специфических для браузеров приставок (например: `-ms-align-items`). Наиболее популярные CSS Preprocessors: [SASS](https://sass-lang.com/), [LESS](http://lesscss.org/), [Stylus](https://stylus-lang.com/).

**Статический рендеринг** - трансляция приложения (Angular/React/Vue), а также формирование сборка (bundle) осуществляется на рабочем месте программиста, либо на сервере сборки. Полученный bundle доставляется в браузер клиента. Для получения актуальных данных, выполняются http-запросы к API (например, с использованием REST API, или GraphGL). Подход хорош тем, что сборки можно размещать на CDN, нагрузка на сервер ограничивается только дополнительными http-запросами.

**Server-Side Rendering (SSR)** - рендеринг, т.е. трансляция кода приложения (Angular/React/Vue) в набор HTML-тэгов обрабатываемых браузером, осуществляется сервером. В этом случае нагрузка переносится на сервер, но снимается с сетевой инфраструктуры, т.е. достаточно будет только одного http-запроса. SSR можно использовать совместно с Angular/React/Vue.

**Chunks** - некоторая часть web-приложения (оформленная как bundle), которая может содержать JavaScript, CSS, HTML-разметку. Разделение на chunks позволяет реализовывать, например, отложенную загрузку («загрузка по требованию») React-компонента с целью минимизировать нагрузку на сетевое взаимодействие.

**Slug** – это то уникальная строка идентификатор, понятная человеку (в отличие от ID) и содержащая только "безопасные" символы:

1. 0-9
2. a-z (общепринято - в нижнем регистре)
3. символ "Тире/минус"
4. символ "Нижнее подчеркивание"

В общем случае это легко читаемый человеком идентификатор чего-либо. Часто используется в шаблоне маршрута http-запроса.

# Hot loaders

Под термином **hot loaders** обычно подразумевают встраиваемые модули (**plugins**) которые позволяют автоматически пересобирать (транслировать/компилировать) компоненты и обновлять содержимое документа в браузере при каких-либо изменениях в исходных файлах (sources).

Для большинства hot reloader-ов используется типовая последовательность действий:

1. Устанавливаем компонент посредством npm/yarn
2. Добавляем plugin в «.babelrc»/«babel.config.js» в секцию «plugins»
3. В серверный «main.js» добавляем require() с указанием необходимости применения импорта компонента
4. В клиентский «main.js» может быть добавлен соответствующий patch

# Расхождения с лекциями

При настройке Loaders, потребовалость использовать более комплексную настройку "attributes", вместо "attrs" из старых версий WebPack. Корректная настройка:


```webpack
module: {
	rules: [
		{
			test: /\.html$/,
			use: [
				{
					loader: "file-loader",
					options: {
						name: "[name].html"
					}
				},
				{
					loader: "extract-loader"
				},
				{
					loader: "html-loader",
					options: {
						attributes: {
							list: [
								{
									tag: 'img',
									attribute: 'src',
									type: 'src',
								},
							]
						}
					}
				}
			]
		},
		{
			test: /\.(jpg|gif|png|jpeg)$/,
			use: [
				{
					loader: "file-loader",
					options: {
						name: "images/[name].[ext]"
					}
				},
			]
		}
	]
}
```

Лекции записывались для WebPack 4.0, но когда я начал прослушивать курс, текущей версией был 4.43. 

Также изменилась версия **babel**, актуальной стала версия 7.9. Ключевое изменение, связанной с babel - модификации названия компонентов. Если раньше использовались такие имена, как: babel-preset-env и babel-runtime, то в 7-ой версии стал использоваться другой формат имён, например: @babel/core, @babel/runtime и @babel/plugin-transform-runtime. Изменение касается как установки модулей посредством npm, так и конфигурационных файлов.

Ещё одно существенное расхождение - в **Babel 7** конфигурация должна храниться в файле "babel.config.json", а не в ".babelrc", как было в Babel 6.

## Deployment на сервера Heroku (Free Account)

Облачный сервис [Heroku](https://www.heroku.com/#) предоставляет бесплатный тарифный план для энтузиастов. Ограничения плана: 0,5 Gb памяти (минимальное Express приложение занимает 27Mb) и 30 минут бездействия для остановки машины.

Критически важно установить Heroku CLI (управляющей консоль) и клиента [Git](https://git-scm.com/downloads).

После регистрации и входа на сайт следует нажать кнопку «Create New App». После выбора имени приложения и проверки его уникальности, сервер сгенерирует инструкцию по созданию и deployment-у приложения.

Команда установки соединения с Heroku: `heroku login`.

Далее следует создать папку с проектом (например, «Heroku-project») и выполнить инициализацию репозитария: `git init`.

Затем следует связать папку и репозитарий: `heroku git:remote -a the-test-on-the-heroku`, где "the-test-on-the-heroku" имя приложения в облаке Heroku.

Инициализация приложения Node.js с поддержкой [Express.js](https://expressjs.com/ru/):

```
npm init
npm i express
```

Простейшая реализация web-сервер в файле "index.js":

```javascript
var express = require('express');
var app = express();
app.get('/', function (req, res) {
	res.send('Hello Heroku World!');
});
const PORT = process.env.PORT || 8080
app.listen(PORT, function () {
	console.log(`Example app listening on port ${PORT}!`);
});
```

Ключевой нюанс кода - Heroku сам выделяет внутренний порт подключения (process.env.PORT).

Добавил файл «.env»:

```
NODE_ENV=production
```

И файл «Procfile», который содержит команду старта проекта. В случае использования WebPack может быть команда ```npm run prod```, которая запускает скрипт "prod" из "package.json":

```
web: node index.js
```

Важными являются всего четыре файла: "Procfile", ".env", "index.js" и "package.json. Нужно выполнить их push в репозитарий на Heroku:

```
git add .
git commit -am "make it better"
git push heroku master
```

В процессе выполнения операции push, применяются скрипты deployment-а web-приложения. В случае успешного размещения, в логах будет указан URL сайта подключения, например: https://the-test-on-the-heroku.herokuapp.com/.

В случае получения сообщения об ошибке, детали можно посмотреть командой: `heroku logs --tail`

В [разделе Add-Ons](https://elements.heroku.com/addons) есть множество Plug-ins, которые позволяют сохранять данные в приложении на Heroku. Пример: Heroku Redis с бесплатным тарифным планом.
