# Что такое архитектура программного обеспечения

The Software Engineering Institute предлагает следующую формулировку: "_The software architecture of a system is the set of structures needed to reason about the system, which compose software elements, relations among them, and properties of both_".

Т.е. архитектура - это о композиции элементов, их взаимодействии и свойствах каждого отдельного элемента в композиции.

Существуют разные взгляды на архитектуру:

- Enterprise architecture принимает во внимание всю компанию или даже группы компаний. Главная задача - обеспечение целостности (holistic approach) и сфокусирована на стратегии обеспечения целостности систем во всех компании. Вы должны смотреть на поведение всех систем компании, на то, как они взаимодействуют друг с другом
- Solution architecture менее абстрактный подход, чем Enterprice architecture. Обычно solution architecture рассматривает одну систему и то, как она взаимодействует со своим окружением
- Software Solution architecture ещё более конкретный подход, который коцентрируется на конкретном проекте, технологиях, которые используются для его разработки и на том, как он взаимодействует с другими проектами. Фокус - внутренняя организация проекта
- Infrastructure architecture сфокусирована на инфраструктурных единицах и на том, какое программное обеспечение используется. Определяет окружение для развертывания систем и стратегии, которые обеспечивают масштабирование, обработку сбоев, надёжность работы сайтов, а также другие инфраструктурно-ориентированные аспекты

## Разработка архитектуры используя принципы Agile

Материал взят из книги "Software Architecture with C++" by Adrian Ostrowski, Piotr Gaczkowski (Packt Publishing, 2021).

Agile, по своей природе, итеративный и инкрементальный. Это означает, что подготовка большого, предварительного дизайна (_upfront design_) - это не вариант для Agile-архитектуры. Вместо этого, маленький, но обоснованный предварительный дизайн - должен являться целью. Наилучший вариант - log решений с рациональным объяснением каждого из них. В этом случае, если видение продукта изменяется, дизайн также должен инкрементально изменяться. Архитектура, разрабатываемая подобным образом называется **эволюционной архитектурой**.

Управление архитектурой не означает необходимость массивного документирования. Фактически, документация должна покрывать только основные аспекты, для того, чтобы сохранять её актуальной (up-to-date). Документация должна быть простой и содержать только релевантное представление системы.

Существует миф, что архитектура является единственным источником правды и ультимативным сборником решений. В Agile, команда принимает решение. Нужно сказать, что критичным является участие stakeholder-а в процессе принятия решений.

Архитектор должен оставаться частью команды разработки настолько часто, чтобы передавать команде свою сильную техническую экспертизу, сформировавшуюся за годы опыта. Архитекторы также должны быть частью процесса оценки и планов изменения архитектуры перед каждой итерацией.

В рамках Agile необходимо работать эффективно и делать только то, что важно. Хорошая идея достичь этих целей - использовать _Domain-driven design_.

## Domain-driven design

Термин _Domain-driven design_ (DDD) был представлен в книге Eric Evans с одноимённым названием. Для простоты, это об улучшении коммуникации между бизнесом и инженерами, а также об обеспечении внимания разработчиков к доменной модели (модель предметной области).

The Agile Manifesto:

- Индивидуумы и взаимодействие важнее, чем процессы и инструменты
- Работающее програмное обеспечение важнее, чем подробная документация
- Взаимодействие с пользователями важнее, чем обсуждение договоров
- Готовность к изменениям важнее, чем следование изначальному плану

Ключевая идея DDD состоит в том, чтобы разобрать прикладную область на отдельные небольшие области и в каждой из таких областей добиться согласованного использования терминов и одинакового понимания процессов внутри областей. Т.е. по сути мы говорим о декомпозиции, но не в коде, а в прикладной области.

## Принципы и шаблоны проектирования

Традиционно считается, что хорошая архитектура воплощает правильные принципы и использует верные шаблоны проектирования. Так же существует целая группа анти-паттернов, т.е. конструкций, которые создают проблемы, а не решают их.

Наиболее распространёнными принципами являются SOLID и DRY.

SOLID - это набор следующих принципов (акроним из первых букв этих пяти принципов):

- Single responisbility principle - класс должен иметь только одну ответственность, т.е. не должен совмещать несколько разных функциональных обязанностей
- Open-closed principle - класс должен быть открыт для расширения, но закрыт для модификаций. Это значит, что если вы разработали какой-то класс, который является базовым для множества производных классов, то изменение в базовом классе могут делать зависимый код хрупким. Однако мешать создавать производные классы не нужно
- Liskov substitution principle - принцип, определяющий то, каким образом следует создавать наследование. Например, хотя квадрат может быть производным классом от прямоугольника, это может приводить к тому, что изменяется интерфейс (у квадрата достаточно указать только длину одной стороны, тогда как у прямоугольника длину и ширину) и из-за этого управлять производными классами также, как и базовым становиться невозможно. Необходимо заботиться о совместимости в управляемости производными классами через указатели, или ссылки на базовые классы. В примере с квадратом и прямоугольником, в качестве базового класса должен был бы быть "геометрическая фигура" с соответствующим интерфейсом
- Interface segregation - идея состоит в том, что пользователя некоторого класса не нужно принуждать к созданию зависимостей, которые ему не нужны. Принцип говорит о том, что вместо создания больших и сложных базовых классов, следует создавать несколько простых классов/интерфейсов, каждый из которых решает свою собственную задачу. Пример: вместо класса "универсальный кухонный прибор" с огромным количеством методов, нужно создать несколько простых классов/интерфейсов: блендер, cutter, и т.д.
- Dependency inversion - принцип используется для decoupling-а, т.е. для устранения слишком высокой сцепленности между разными классами. Практический пример - Dependency Injection

Правило DRY, т.е. "Don't repeat yourself" говорит о том, что следует избегать дублирования кода и использовать уже существующий код. Российский аналог - "не изобретай велосипед (особенно с квадратными колёсами)".

### Coupling and Cohesion

Coupling - это мера того, насколько сильно один модуль зависит от другого. Чем выше сцепленность (high coupling) тем хуже для разработчика. Слабая сцепленность - это цель для разработчика.

Cohesion - это мера того, насколько сильно элементы модуля связаны.В случае высокой степени связанности (high cohesion), компоненты в одном модуле сильно связаны. Другими словами, это свойство общности компонентов модуля.

Хорошо спроектированная система отвечает правилу: low coupling, high cohesion.
