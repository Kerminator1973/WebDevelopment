# Что такое архитектура программного обеспечения

The Software Engineering Institute предлагает следующую формулировку: "_The software architecture of a system is the set of structures needed to reason about the system, which compose software elements, relations among them, and properties of both_".

Т.е. архитектура - это о композиции элементов, их взаимодействии и свойствах каждого отдельного элемента в композиции.

Существуют разные взгляды на архитектуру:

- Enterprise architecture принимает во внимание всю компанию или даже группы компаний. Главная задача - обеспечение целостности (holistic approach) и сфокусирована на стратегии обеспечения целостности систем во всех компании. Вы должны смотреть на поведение всех систем компании, на то, как они взаимодействуют друг с другом
- Solution architecture менее абстрактный подход, чем Enterprice architecture. Обычно solution architecture рассматривает одну систему и то, как она взаимодействует со своим окружением
- Software Solution architecture ещё более конкретный подход, который коцентрируется на конкретном проекте, технологиях, которые используются для его разработки и на том, как он взаимодействует с другими проектами. Фокус - внутренняя организация проекта
- Infrastructure architecture сфокусирована на инфраструктурных единицах и на том, какое программное обеспечение используется. Определяет окружение для развертывания систем и стратегии, которые обеспечивают масштабирование, обработку сбоев, надёжность работы сайтов, а также другие инфраструктурно-ориентированные аспекты

## Разработка архитектуры используя принципы Agile

Материал взят из книги "Software Architecture with C++" by Adrian Ostrowski, Piotr Gaczkowski (Packt Publishing, 2021).

Agile, по своей природе, итеративный и инкрементальный. Это означает, что подготовка большого, предварительного дизайна (_upfront design_) - это не вариант для Agile-архитектуры. Вместо этого, маленький, но обоснованный предварительный дизайн - должен являться целью. Наилучший вариант - log решений с рациональным объяснением каждого из них. В этом случае, если видение продукта изменяется, дизайн также должен инкрементально изменяться. Архитектура, разрабатываемая подобным образом называется **эволюционной архитектурой**.

Управление архитектурой не означает необходимость массивного документирования. Фактически, документация должна покрывать только основные аспекты, для того, чтобы сохранять её актуальной (up-to-date). Документация должна быть простой и содержать только релевантное представление системы.

Существует миф, что архитектура является единственным источником правды и ультимативным сборником решений. В Agile, команда принимает решение. Нужно сказать, что критичным является участие stakeholder-а в процессе принятия решений.

Архитектор должен оставаться частью команды разработки настолько часто, чтобы передавать команде свою сильную техническую экспертизу, сформировавшуюся за годы опыта. Архитекторы также должны быть частью процесса оценки и планов изменения архитектуры перед каждой итерацией.

В рамках Agile необходимо работать эффективно и делать только то, что важно. Хорошая идея достичь этих целей - использовать _Domain-driven design_.

## Domain-driven design

Термин _Domain-driven design_ (DDD) был представлен в книге Eric Evans с одноимённым названием. Для простоты, это об улучшении коммуникации между бизнесом и инженерами, а также об обеспечении внимания разработчиков к доменной модели (модель предметной области).

The Agile Manifesto:

- Индивидуумы и взаимодействие важнее, чем процессы и инструменты
- Работающее програмное обеспечение важнее, чем подробная документация
- Взаимодействие с пользователями важнее, чем обсуждение договоров
- Готовность к изменениям важнее, чем следование изначальному плану

Ключевая идея DDD состоит в том, чтобы разобрать прикладную область на отдельные небольшие области и в каждой из таких областей добиться согласованного использования терминов и одинакового понимания процессов внутри областей. Т.е. по сути мы говорим о декомпозиции, но не в коде, а в прикладной области.

## Принципы и шаблоны проектирования

Традиционно считается, что хорошая архитектура воплощает правильные принципы и использует верные шаблоны проектирования. Так же существует целая группа анти-паттернов, т.е. конструкций, которые создают проблемы, а не решают их.

Наиболее распространёнными принципами являются SOLID и DRY.

SOLID - это набор следующих принципов (акроним из первых букв этих пяти принципов):

- Single responsibility principle (SRP) - класс должен иметь только одну ответственность, т.е. не должен совмещать несколько разных функциональных обязанностей
- Open-closed principle - класс должен быть открыт для расширения, но закрыт для модификаций. Это значит, что если вы разработали какой-то класс, который является базовым для множества производных классов, то изменение в базовом классе могут делать зависимый код хрупким. Однако мешать создавать производные классы не нужно
- Liskov substitution principle - принцип, определяющий то, каким образом следует создавать наследование. Например, хотя квадрат может быть производным классом от прямоугольника, это может приводить к тому, что изменяется интерфейс (у квадрата достаточно указать только длину одной стороны, тогда как у прямоугольника длину и ширину) и из-за этого управлять производными классами также, как и базовым становиться невозможно. Необходимо заботиться о совместимости в управляемости производными классами через указатели, или ссылки на базовые классы. В примере с квадратом и прямоугольником, в качестве базового класса должен был бы быть "геометрическая фигура" с соответствующим интерфейсом
- Interface segregation - идея состоит в том, что пользователя некоторого класса не нужно принуждать к созданию зависимостей, которые ему не нужны. Принцип говорит о том, что вместо создания больших и сложных базовых классов, следует создавать несколько простых классов/интерфейсов, каждый из которых решает свою собственную задачу. Пример: вместо класса "универсальный кухонный прибор" с огромным количеством методов, нужно создать несколько простых классов/интерфейсов: блендер, cutter, и т.д.
- Dependency inversion - принцип используется для decoupling-а, т.е. для устранения слишком высокой сцепленности между разными классами. Практический пример - Dependency Injection

Правило DRY, т.е. "Don't repeat yourself" говорит о том, что следует избегать дублирования кода и использовать уже существующий код. Российский аналог - "не изобретай велосипед (особенно с квадратными колёсами)".

### Coupling and Cohesion

Coupling - это мера того, насколько сильно один модуль зависит от другого. Чем выше сцепленность (high coupling) тем хуже для разработчика. Слабая сцепленность - это цель для разработчика.

Cohesion - это мера того, насколько сильно элементы модуля связаны.В случае высокой степени связанности (high cohesion), компоненты в одном модуле сильно связаны. Другими словами, это свойство общности компонентов модуля.

Хорошо спроектированная система отвечает правилу: low coupling, high cohesion.

## Stateful и Stateless

**Stateful** - приложение хранит состояние, связанное с установленным соединением и при получении запроса использует его для выполнения операции, объединяя его с данными, которые поступили в http-запросе. Пример серверного решения - FTP.

**Stateless** - все необходимые данные для выполнения операции поступают в http-запросе.

>Идемпотентность (_idempotence_) — это свойство операции, которое означает, что её многократное применение не приводит к дополнительным изменениям состояния, если операция уже была применена один раз.

Stateless приложения, обычно, очень хорошо горизонтально масштабируются и имеют более простую структуру кода. Однако в http-запросе приходится передавать все необходимые для его выполнения данные. В случае клиент/серверных приложений, Stateless-сервер может потребовать хранения некоторого состояния на клиенте. Часто на клиенте хранится аутентификационный токен (и передаётся на сервер, например, посредством cookie).

Ещё одно преимущество Stateless серверных приложений - их существенно легче тестировать, а также разрабатывать для них тесты автоматизации.

В 2025 году считается, что простые и масштабируемые системы можно получить только при использовании Stateless-подхода. Если архитектура web-приложения получается Stateful, вероятно в дизайне архитектуры есть ошибка.

## Ограничения монолита

Под монолитом обычно подразумевают систему, в которой весь функционал системы реализован в одном исполняемом модуле.

Монолит прекрасен с точки зрения минимизации издержек на коммуникацию подсистем друг с другом (они почти нулевые). Код монолита обычно значительно проще, чем код распределённой системы.

Однако для больших промышленных приложений монолит очень редко подходит. Основная проблема связана с развертыванием и сопровождением системы.

Предположим, что у нас есть система с 1000 функций. В одной из функций была найдена ошибка. В случае монолита потребуется обновлять всю систему при исправлении каждой ошибки. Если система разделена, например, на 200 сервисов, то при исправлении ошибки в одном сервисе, необходимо переопубликовать только этот сервис.

В монолите проблемы с утечкой ресурсов распространяются на весь исполняемый файл. В микросервисной архитектуре - только на отдельный сервис.

Основная проблема развертывания связана с разным объёмом вычислений необходимых для разных функций системы. Например, операция авторизации выполняется один раз на пользовательскую сессию и может быть достаточно одного виртуального сервера для выполнения этой задачи для всех пользователей. А задач генерации пользовательского интерфейса системы может выполняться, например, по 500 штук в секунду и для обеспечения приемлемого времени отклика необходимо 10 виртуальных серверов. Используя микро-сервисную архитектуру, мы можем развернуть 10 виртуальных серверов, выполняющих одну функцию, требующую минимальных ресурсов для своей работы. Или же нам пришлось запустить 10 тяжёлых монолитов.

В части управления разработкой, проще разделить большую задачу на множество небольших независимых задач и раздать их разным рабочим группам.

Важно понимать, что микро-сервисная архитектура гораздо менее эффективно использует вычислительные ресурсы, требует комплексной системы мониторинга и может приводить к целому ряду специфических проблем, включая "проблемы гранулярности" и "синхронизации состояния сервисов".

## Сервис-ориентированные архитектуры

SOA означает, что бизнес-функции создаются модульными и представляют различные сервисы, которые может использовать приложение.

Адвокаты SOA пропагандируют следующий манифест приоритетов:

- Бизнес-ценность важнее технической стратегии
- Стратегические цели важнее, чем специфические проектные преимущества (projecy-specific benefits)
- Внутренняя взаимозаменяемость важнее, чем индивидуальная интеграция (custom integration)
- Совместно используемые сервисы важнее, чем целевая реализация (purpose-specific implementations)
- Гибкость важнее оптимизации
- Эволюционные улучшения важнее, чем преследование изначального совершенства

## Комбинации архитектурных шаблонов

Микросервисы часто используются совместно с таким шаблонами проектирования, как cloud-native computing, serverless applications и с легковесными контейнерами приложений (например, Docker).

Как SOA, так и микросервисная архитектура, при правильном использовании, позволяют создавать сильно связанные и слабо сцепленные компоненты.

Следует заметить, что при разработке микросервисов часто используются REST, или gRPC, хотя изначально эти подходы использовались для SOA.

Чтобы обеспечить эффективную работу сервис-ориентированной архитектуры, требуется принять множество сложных технических решений, таки как выбор:

- как построить API и какой API Gateway использовать
- какая подсистема регистрации сервисов будет использована (service registries)
- как будет балансироваться нагрузка
- как обеспечить устойчивость к сбоям
- как управлять конфигурациями
- и самое главное - какой технологический stack должен быть использован

## Event-based архитектуры

Event-based архитектуры построены вокруг обработки событий. В таких архитектурах есть компоненты, которые генерируют события, есть каналы, по которым события доставляются и есть подписчики, которые реагируют на возникающие события. Этот подход является асинхронным, обладает хорошей производительностью и отлично масштабируется. Также такие системы легко развертывать (deploy).

Однако, для того, чтобы подобные системы работали эффективно, необходимо обеспечить очень надёжные каналы доставки сообщений, в которых отсутствуют потери. Базой для подобных систем являются очереди сообщений (message queues).

См. также: Correlation ID pattern.

Широко применяются две топологии: **mediator topology** и **broker-based topology**.

Mediator topology лучше всего используется в том случае, если требуется много задач, или шагов, которые выполняются независимо друг от друга. Все события изначально лежат в очереди медиатора, которые знает, что должно быть сделано, но не выполняет задачи сам, а передаёт их соответствующему каналу обработки событий.

См.: Business Process Management (BPM), Business Process Execution Language (BPEL), Apache Camel, Mule ESB.

С другой стороны, broker - это легковесный компонент, который содержит все очереди, но не выполняет их оркестрацию, а просто позволяет обработчикам "вытягивать" нужные им сообщения из очереди. Пример такой очереди - ZeroMQ, написанный на С++, обладающий очень низкой латентностью и почти не выполняющий избыточных действий.

## Многоуровневые архитектуры (N-Tier Architecture)

Многоуровневыми называют архитектуры, в кодорых код структурирован посредством использования слоёв. Англоязычный термин - _N-Tier Architecture_.

Примеры многоуровневых архитектур:

- Model-View-Controller
- Model-View-ViewModel
- Entity-Control-Boundary

Многоуровневые архитектуры позволяют снизить сложность кода, реализовать подход _the separation of concerns_. Они упрощают сопровождение кода и обеспечивают его повторное использование.

Также очень важная особенность - этот тип архитектур известен почти всем программистам и его легко реализовывать.

## Как описывать архитектуру

Существуют специализированные подходы для описания архитектуры, например, **The Open-Group Architecture Framework** (TOGAF). Этот инструмент полагается на четыре области, которые описывают архитектуру:

- Бизнес-архитектура (стратегия, организация, ключевые процессы, и т.д.)
- Архитектура данных (управление данными на физическом и логическом уровнях)
- Архитектура приложения ("чертежи"/blueprints для конкретных систем)
- Техническая архитектура (используемые аппаратное и программное обеспечение, а также сетевая инфраструктура)

Существуют и более простых подходы, такие как "4 + 1 model" и "C4 model", которые во многом полагаются на диаграммы UML.

### 4 + 1 model

Содержит четыре основных отображения:

- The logical view: отображает как функциональность предоставляется пользователям. Показывает системные компоненты (объекты) и как они взаимодействуют друг с другом. В общем случае, содержит диаграммы классов и состояний. Если у вас сотни классов, или вы хотите более детально отобразить взаимодействие между ними, так же рекомендуется использовать communication diagrams, или sequences diagrams (UML)
- The process view: строиться вокруг поведения системы при работе. Отображает рабочие процессы и их взаимодействие друг с другом, а также с внешними системами. Обычно используются activity diagrams и interaction diagrams. Описывает, в том числе и не функциональные требования: многопоточность, производительность, требования доступности компонентов, а также масштабирование системы
- The development view используется для декомпозиции подсистем и показывает, как организована система внутри. Акцентируется на повторном использовании компонентов, ограничений инструментальных средств, слоях ПО, модульности, разбиении на пакеты (packaging) и описании окружения исполнения кода
- The physical view используется для отражения используемого аппаратного обеспечения. Предназначается для системных инженеров, которые проверяют исполнение не функциональных требований

Цифра "1" в названии соответствует описанию сценариев, которые связывают все другие представления вместе. В терминах UML используются _use case diagrams_.

## Различные сервисные модели

Для больших систем критичным является инфраструктура, на которой эта система работает. Выьор инфраструктуры критически влияет на стоимость эксплуатации системы и её управляемость. Различаюся следующие **сервисные модели**:

- On-premises: классический способ управления инфраструктурой "до-облачной эру". У вас есть сервер подключенный к интернет и вы обслуживаете его самостоятельно
- Infrastructure as a Service (IaaS): облачный провайдер предоставляет виртуальные машины, контейнеры, или bare-metal машины, сетевые сервисы (DNS-сервера, маршрутизацию и firewalls), накопители данных и их backup/restore. Начиная с операционных системы всё остальное вы делаете сами
- Platform as a Service (PaaS): провайдер услуг предоставляет не только аппаратное обеспечение и его обслуживание, на также и платформу: операционную систему, СУБД, сервисы аутентификации пользователя, другие требуемые middleware/ Вам необходимо встраивать интеграцию с этими сервисами в ваше приложение
- Software as a Service (SaaS): иногда вам не нужно разрабатывать сложное программное обеспечение и достаточно, чтобы какое-то уже существующее ПО гарантированного работала в соответствии с условиями лицензионного соглашения. Например: Office 365, Google Docs, Slack, сервера компьютерных игр, Customer Relationship Management (CRM), WordPress, и т.д.
- Function as a Service (FaaS): набирает популярность в последнее время. Приложение разрабатывается как набор отдельных функций, каждая из которых выполняет какое-то действие в системе. Инфраструктура сама понимает когда и где создавать копию среды выполнения для конкретной функции, управляет временем её жизни, и т.д. В этой модели разработчики системы вообще ничего не знают про инфраструктуру и не решают задач связанных с её сопровождением

### Проблемы при работе распределённых приложений

При разработке распределённых приложений нужно всегда помнить, что:

- Сеть не работает надёжно (Reliable). Это очень сложная инфраструктура и может ломаться самым неочевидным образом
- Латентность (Latency) не нулевая. Часто задержки в сети могут быть не заметны на глаз, но они всегда есть и не аккуратный код может сделать их неприемлемыми
- Полоса пропускания (Bandwidth) ограниченная. Сигнал идёт по разным участкам и некоторые участки могут быть очень узкими
- Сеть не является безопасной (Secure). Необходимо постоянно обновлять компоненты, обучать людей, выполнять аудит
- Топология сети изменяется. По этой причине нельзя привязываться к IP-адресам, а следует получать их от DNS-сервера. Это особенно актуально при автоматическом масштабировании приложения
- Нет единого администратора, который решит любую проблему
- Стоимость доставки сообщений не нулевая. Стоимость может быть очень большой при использовании сервисов облачных провайдеров
- Сеть не является гомогенно (Homogeneous). Это значит, что на разных машинах могут быть слегка разные конфигурационных скрипты, версии ОС и компонентов и эти отличия могут критически влиять на работоспособность распределённых приложений

## SLA

Общей практикой для облачных приложений является предоставление информации об Service-Level Agreement (SLA), который определяет, сколько времени система может быть не доступна для обслуживания в некоторый календарный период.

В действительности, посчёт SLA не такой простой, как может показаться на первый взгляд. Допустим, что SLA используемой нами облачного сервиса (инфраструктура) - 99,99%, а наш сервис также декларируется как доступный 99,99%. Совокупный (_compound_) SLA будет равен 99,99% * 99,99% = 99,98%. Если поверх инфраструктуры (hardware + OS) находится ещё и некоторая платформа, то она так же имеет свой SLA и совокупный SLA будет ещё меньше.

## Обеспечение высокой надёжности (fault-tolerant systems)

Один из способов обеспечения высокой надёжности - создание избыточных вычислительных ресурсов (серверов). Для этого подхода используется термин **Redundancy**. Задачи могут распределяться по разным серверам, часть сервером может находится в простое в режиме stand by. Ключевая особенность подхода состоит в том, что система должна быть самоконфигурируемой, т.е. работающие сервера должны "договариваться" между собой о том, как они будут распределять работу и, возможно, какой из серверов будет выполнять координацию, т.е. будет лидером. Для решения этих задач используются специализированные протоколы, такие как **Leader election** и **Consensus**.

При работе с базами данных, для повышения горизонтальной масштабируемости часто используют репликацию, что означает, что несколько серверов могут выполнять запросы параллельно. Часто используется схема, в которое есть только один сервер баз данных осуществляющий модификацию данных (Master). Остальные сервера выполняют только запросы для получения данных (Slaves). Основная техническая проблема - синхронизация данных между Master и Slaves.

Существуют также схему Multi-master replication, в которых осуществляется синхронизация между несколькими экземплярами серверов СУБД. Примеры решений: Microsoft's Active Directory, OpenLDAP, Apache's CouchDB, Postgres-XL. 

Компания, которая специализируется на горизонтальном масштабировании Postgres - [Citus](https://www.citusdata.com/).

Один из подходов, значительно упрощающих горизонтальное масштабирование систем - применение очередей сообщений. Очередь содержит постоянное хранилище данных и работает назависимо от серверов-исполнителей. Использование очередей сообщений приводит к увеличению латентности системы при обработке сообщений (иногда очень существенно), но такая архитектура решения автоматически обеспечивает горизонтальное масштабирование, а также устойчиво к выходу части серверов-исполнителей из строя.

Примеры продуктов для организации очередей сообщений: Amazon's SQS, Azure's Service Bus, Apache Kafka, ZeroMQ.
