# Что такое архитектура программного обеспечения

The Software Engineering Institute предлагает следующую формулировку: "_The software architecture of a system is the set of structures needed to reason about the system, which compose software elements, relations among them, and properties of both_".

Т.е. архитектура - это о композиции элементов, их взаимодействии и свойствах каждого отдельного элемента в композиции.

Существуют разные взгляды на архитектуру:

- Enterprise architecture принимает во внимание всю компанию или даже группы компаний. Главная задача - обеспечение целостности (holistic approach) и сфокусирована на стратегии обеспечения целостности систем во всех компании. Вы должны смотреть на поведение всех систем компании, на то, как они взаимодействуют друг с другом
- Solution architecture менее абстрактный подход, чем Enterprice architecture. Обычно solution architecture рассматривает одну систему и то, как она взаимодействует со своим окружением
- Software Solution architecture ещё более конкретный подход, который коцентрируется на конкретном проекте, технологиях, которые используются для его разработки и на том, как он взаимодействует с другими проектами. Фокус - внутренняя организация проекта
- Infrastructure architecture сфокусирована на инфраструктурных единицах и на том, какое программное обеспечение используется. Определяет окружение для развертывания систем и стратегии, которые обеспечивают масштабирование, обработку сбоев, надёжность работы сайтов, а также другие инфраструктурно-ориентированные аспекты

## Разработка архитектуры используя принципы Agile

Материал взят из книги "Software Architecture with C++" by Adrian Ostrowski, Piotr Gaczkowski (Packt Publishing, 2021).

Agile, по своей природе, итеративный и инкрементальный. Это означает, что подготовка большого, предварительного дизайна (_upfront design_) - это не вариант для Agile-архитектуры. Вместо этого, маленький, но обоснованный предварительный дизайн - должен являться целью. Наилучший вариант - log решений с рациональным объяснением каждого из них. В этом случае, если видение продукта изменяется, дизайн также должен инкрементально изменяться. Архитектура, разрабатываемая подобным образом называется **эволюционной архитектурой**.

Управление архитектурой не означает необходимость массивного документирования. Фактически, документация должна покрывать только основные аспекты, для того, чтобы сохранять её актуальной (up-to-date). Документация должна быть простой и содержать только релевантное представление системы.

Существует миф, что архитектура является единственным источником правды и ультимативным сборником решений. В Agile, команда принимает решение. Нужно сказать, что критичным является участие stakeholder-а в процессе принятия решений.

Архитектор должен оставаться частью команды разработки настолько часто, чтобы передавать команде свою сильную техническую экспертизу, сформировавшуюся за годы опыта. Архитекторы также должны быть частью процесса оценки и планов изменения архитектуры перед каждой итерацией.

В рамках Agile необходимо работать эффективно и делать только то, что важно. Хорошая идея достичь этих целей - использовать _Domain-driven design_.

## Domain-driven design

Термин _Domain-driven design_ (DDD) был представлен в книге Eric Evans с одноимённым названием. Для простоты, это об улучшении коммуникации между бизнесом и инженерами, а также об обеспечении внимания разработчиков к доменной модели (модель предметной области).

The Agile Manifesto:

- Индивидуумы и взаимодействие важнее, чем процессы и инструменты
- Работающее програмное обеспечение важнее, чем подробная документация
- Взаимодействие с пользователями важнее, чем обсуждение договоров
- Готовность к изменениям важнее, чем следование изначальному плану

Ключевая идея DDD состоит в том, чтобы разобрать прикладную область на отдельные небольшие области и в каждой из таких областей добиться согласованного использования терминов и одинакового понимания процессов внутри областей. Т.е. по сути мы говорим о декомпозиции, но не в коде, а в прикладной области.

## Принципы и шаблоны проектирования

Традиционно считается, что хорошая архитектура воплощает правильные принципы и использует верные шаблоны проектирования. Так же существует целая группа анти-паттернов, т.е. конструкций, которые создают проблемы, а не решают их.

Наиболее распространёнными принципами являются SOLID и DRY.

SOLID - это набор следующих принципов (акроним из первых букв этих пяти принципов):

- Single responsibility principle (SRP) - класс должен иметь только одну ответственность, т.е. не должен совмещать несколько разных функциональных обязанностей
- Open-closed principle - класс должен быть открыт для расширения, но закрыт для модификаций. Это значит, что если вы разработали какой-то класс, который является базовым для множества производных классов, то изменение в базовом классе могут делать зависимый код хрупким. Однако мешать создавать производные классы не нужно
- Liskov substitution principle - принцип, определяющий то, каким образом следует создавать наследование. Например, хотя квадрат может быть производным классом от прямоугольника, это может приводить к тому, что изменяется интерфейс (у квадрата достаточно указать только длину одной стороны, тогда как у прямоугольника длину и ширину) и из-за этого управлять производными классами также, как и базовым становиться невозможно. Необходимо заботиться о совместимости в управляемости производными классами через указатели, или ссылки на базовые классы. В примере с квадратом и прямоугольником, в качестве базового класса должен был бы быть "геометрическая фигура" с соответствующим интерфейсом
- Interface segregation - идея состоит в том, что пользователя некоторого класса не нужно принуждать к созданию зависимостей, которые ему не нужны. Принцип говорит о том, что вместо создания больших и сложных базовых классов, следует создавать несколько простых классов/интерфейсов, каждый из которых решает свою собственную задачу. Пример: вместо класса "универсальный кухонный прибор" с огромным количеством методов, нужно создать несколько простых классов/интерфейсов: блендер, cutter, и т.д.
- Dependency inversion - принцип используется для decoupling-а, т.е. для устранения слишком высокой сцепленности между разными классами. Практический пример - Dependency Injection

Правило DRY, т.е. "Don't repeat yourself" говорит о том, что следует избегать дублирования кода и использовать уже существующий код. Российский аналог - "не изобретай велосипед (особенно с квадратными колёсами)".

### Coupling and Cohesion

Coupling - это мера того, насколько сильно один модуль зависит от другого. Чем выше сцепленность (high coupling) тем хуже для разработчика. Слабая сцепленность - это цель для разработчика.

Cohesion - это мера того, насколько сильно элементы модуля связаны.В случае высокой степени связанности (high cohesion), компоненты в одном модуле сильно связаны. Другими словами, это свойство общности компонентов модуля.

Хорошо спроектированная система отвечает правилу: low coupling, high cohesion.

## Stateful и Stateless

**Stateful** - приложение хранит состояние, связанное с установленным соединением и при получении запроса использует его для выполнения операции, объединяя его с данными, которые поступили в http-запросе. Пример серверного решения - FTP.

**Stateless** - все необходимые данные для выполнения операции поступают в http-запросе.

>Идемпотентность (_idempotence_) — это свойство операции, которое означает, что её многократное применение не приводит к дополнительным изменениям состояния, если операция уже была применена один раз.

Stateless приложения, обычно, очень хорошо горизонтально масштабируются и имеют более простую структуру кода. Однако в http-запросе приходится передавать все необходимые для его выполнения данные. В случае клиент/серверных приложений, Stateless-сервер может потребовать хранения некоторого состояния на клиенте. Часто на клиенте хранится аутентификационный токен (и передаётся на сервер, например, посредством cookie).

Ещё одно преимущество Stateless серверных приложений - их существенно легче тестировать, а также разрабатывать для них тесты автоматизации.

В 2025 году считается, что простые и масштабируемые системы можно получить только при использовании Stateless-подхода. Если архитектура web-приложения получается Stateful, вероятно в дизайне архитектуры есть ошибка.

## Ограничения монолита

Под монолитом обычно подразумевают систему, в которой весь функционал системы реализован в одном исполняемом модуле.

Монолит прекрасен с точки зрения минимизации издержек на коммуникацию подсистем друг с другом (они почти нулевые). Код монолита обычно значительно проще, чем код распределённой системы.

Однако для больших промышленных приложений монолит очень редко подходит. Основная проблема связана с развертыванием и сопровождением системы.

Предположим, что у нас есть система с 1000 функций. В одной из функций была найдена ошибка. В случае монолита потребуется обновлять всю систему при исправлении каждой ошибки. Если система разделена, например, на 200 сервисов, то при исправлении ошибки в одном сервисе, необходимо переопубликовать только этот сервис.

В монолите проблемы с утечкой ресурсов распространяются на весь исполняемый файл. В микросервисной архитектуре - только на отдельный сервис.

Основная проблема развертывания связана с разным объёмом вычислений необходимых для разных функций системы. Например, операция авторизации выполняется один раз на пользовательскую сессию и может быть достаточно одного виртуального сервера для выполнения этой задачи для всех пользователей. А задач генерации пользовательского интерфейса системы может выполняться, например, по 500 штук в секунду и для обеспечения приемлемого времени отклика необходимо 10 виртуальных серверов. Используя микро-сервисную архитектуру, мы можем развернуть 10 виртуальных серверов, выполняющих одну функцию, требующую минимальных ресурсов для своей работы. Или же нам пришлось запустить 10 тяжёлых монолитов.

В части управления разработкой, проще разделить большую задачу на множество небольших независимых задач и раздать их разным рабочим группам.

Важно понимать, что микро-сервисная архитектура гораздо менее эффективно использует вычислительные ресурсы, требует комплексной системы мониторинга и может приводить к целому ряду специфических проблем, включая "проблемы гранулярности" и "синхронизации состояния сервисов".

## Сервис-ориентированные архитектуры

SOA означает, что бизнес-функции создаются модульными и представляют различные сервисы, которые может использовать приложение.

Адвокаты SOA пропагандируют следующий манифест приоритетов:

- Бизнес-ценность важнее технической стратегии
- Стратегические цели важнее, чем специфические проектные преимущества (projecy-specific benefits)
- Внутренняя взаимозаменяемость важнее, чем индивидуальная интеграция (custom integration)
- Совместно используемые сервисы важнее, чем целевая реализация (purpose-specific implementations)
- Гибкость важнее оптимизации
- Эволюционные улучшения важнее, чем преследование изначального совершенства

## Комбинации архитектурных шаблонов

Микросервисы часто используются совместно с таким шаблонами проектирования, как cloud-native computing, serverless applications и с легковесными контейнерами приложений (например, Docker).

Как SOA, так и микросервисная архитектура, при правильном использовании, позволяют создавать сильно связанные и слабо сцепленные компоненты.

Следует заметить, что при разработке микросервисов часто используются REST, или gRPC, хотя изначально эти подходы использовались для SOA.

Чтобы обеспечить эффективную работу сервис-ориентированной архитектуры, требуется принять множество сложных технических решений, таки как выбор:

- как построить API и какой API Gateway использовать
- какая подсистема регистрации сервисов будет использована (service registries)
- как будет балансироваться нагрузка
- как обеспечить устойчивость к сбоям
- как управлять конфигурациями
- и самое главное - какой технологический stack должен быть использован

## Event-based архитектуры

Event-based архитектуры построены вокруг обработки событий. В таких архитектурах есть компоненты, которые генерируют события, есть каналы, по которым события доставляются и есть подписчики, которые реагируют на возникающие события. Этот подход является асинхронным, обладает хорошей производительностью и отлично масштабируется. Также такие системы легко развертывать (deploy).

Однако, для того, чтобы подобные системы работали эффективно, необходимо обеспечить очень надёжные каналы доставки сообщений, в которых отсутствуют потери. Базой для подобных систем являются очереди сообщений (message queues).

См. также: Correlation ID pattern.

Широко применяются две топологии: **mediator topology** и **broker-based topology**.

Mediator topology лучше всего используется в том случае, если требуется много задач, или шагов, которые выполняются независимо друг от друга. Все события изначально лежат в очереди медиатора, которые знает, что должно быть сделано, но не выполняет задачи сам, а передаёт их соответствующему каналу обработки событий.

См.: Business Process Management (BPM), Business Process Execution Language (BPEL), Apache Camel, Mule ESB.

С другой стороны, broker - это легковесный компонент, который содержит все очереди, но не выполняет их оркестрацию, а просто позволяет обработчикам "вытягивать" нужные им сообщения из очереди. Пример такой очереди - ZeroMQ, написанный на С++, обладающий очень низкой латентностью и почти не выполняющий избыточных действий.

## Многоуровневые архитектуры (N-Tier Architecture)

Многоуровневыми называют архитектуры, в кодорых код структурирован посредством использования слоёв. Англоязычный термин - _N-Tier Architecture_.

Примеры многоуровневых архитектур:

- Model-View-Controller
- Model-View-ViewModel
- Entity-Control-Boundary

Многоуровневые архитектуры позволяют снизить сложность кода, реализовать подход _the separation of concerns_. Они упрощают сопровождение кода и обеспечивают его повторное использование.

Также очень важная особенность - этот тип архитектур известен почти всем программистам и его легко реализовывать.
