# Пример разработки компонента выбора модели прибора DORS

Средствами Visual Studio 2022 сгенерирован шаблон приложения Blazor WebAssembly.

Поскольку планируется добавить компонент для выбора модели прибора, т.е. повторно используемый компонент, имеет смысл разместить его в папке "Shared". Имя компонента - ModelSelector.razor. Для удобства тестирования компонента, его следует сразу же разместить в родительской форме, доступной в приложении, например, на странице "Counter.razor". Для этого достаточно добавить в верстку компонент:

```csharp
<SelectModel.Shared.ModelSelector />
```

Имя компонента складывается из названия проекта, имени папки "Shared" и имени компонента. Мы можем существенно упростить верстку посредством использования директивы **using**:

```csharp
@page "/counter"
@using SelectModel.Shared
...
<ModelSelector />
```

В соответствии с поставленной задачей, компонент должен содержать три выпадающих списка: название прибора, страна для которой выполнена кастомизация прибора и исполнение, т.е. набор функций, чаще всего - специфический для конкретного заказчика.

> Примеры моделей приборов есть в \RUFServerLite\playground\attribs\index.js

Далее следует добавить в разметку компонента три выпадающих списка.

Первый же взгляд на прототип подсказывает, что каждый из выпадающих списков также можно оформить как отдельный компонент, поскольку у них есть общие свойства: список, выбранный элемент, блокировка выбора (если предыдущий элемент ещё не был выбран), callback-и, и т.д.

Один из ключевых вопросов в дизайне компонента - как именно следует хранить информацию о моделях. Результатом выбора модели должен быть числовой идентификатор. На каждом из этапов выбора данных может осуществляться обновление содержимого pull-down list. Логичный шаг - добавить основные реакции на действия пользователя и посмотреть, в каком виде данные было бы удобно использовать в коде.

> При отладке кода столкнулся со странной ситуацией: точка останова не страбатывает в Visual Studio 2022, но сам код выполняется и можно увидеть выводт в консоль браузера, который осуществляется строкой: `Console.WriteLine($"Selected model: {model}");`

## Переключение фокуса ввода

После того, как динамическая загрузка списка заработала, следует добавить функции переключения фокуса ввода на следующий элемент выпадающего списка, раскрытие его и приведение всех дочерних органов управления в начальное состояние.

> Реализация переключения фокуса сопряжена с необходимостью выполнения JavaScript-кода, поскольку в Blazor нет возможности вызвать метод focus() у списка. Это усложняет реализацию, поскольку её код с этого момента приходится писать как на C#, так и на JavaScript.

### Последовательность действий для переключения фокуса ввода

Создаём уникальный идентификатор выпадающего списка с помощью Guid:

```csharp
@inject IJSRuntime JSRuntime

<select id="@GenerateId()" @onchange="OnSelectionChanged">
    // ...
</select>
```

Запоминаем в дочернем компоненте этот уникальный идентификатор:

```csharp
@code {
    // ...

    // Сгенерированный при вызове GenerateId() уникальный идентификатор списка (select)
    private string selectId = String.Empty;

    private string GenerateId()
    {
        selectId = $"{Guid.NewGuid()}";
        return selectId;
    }
}
```

При необходимости переключения фокуса, в родительском компоненте вызываем метод SetFocus() дочернего компонента, на который следует переключить фокус:

```csharp
private void onSelectModel(string model)
{
    // ...

    countrySelector?.SetFocus();
}
```

Вызываем JavaScript-код, который умеет переключать фокус:

```csharp
public void SetFocus()
{
    JSRuntime.InvokeVoidAsync("setFocusOnChildInput", selectId).GetAwaiter().GetResult();
}
```

В JavaScript-коде переключаем фокус:

```html
<script>
    function setFocusOnChildInput(id) {
        const dropdown = document.getElementById(id);
        dropdown.focus();
    }
</script>
```

Приведённый выше подход работает, но он выглядит переусложнённым и, кроме того, он не раскрывает выпадающее меню при переключении фокуса на него. Вероятно, следует использовать Bootstrap 5 и имеющиеся в нём дополнительные возможности.

## Подключение библиотеки FluentUI

Подобная задача уже была решена мной для jQuery/UI и Boostrap 5. Существует реализация Bootstap 5 для Blazor от [Vikram Reddy](./blazor_bootstrap.md), однако в этом инструменте есть определённые ограничения. Более интересным кажется инструмент от Microsoft - FluentUI. [Fluent](https://fluent2.microsoft.design/get-started/design) - это концепция дизайна пользовательского интерфейса от Microsoft.

Установка библиотеки:

```shell
dotnet add package Microsoft.Fast.Components.FluentUI
```

Для полноценного использования элементов FluentUI, необходимо зарегистрировать специализированный сервис, вызовом AddFluentUIComponents():

```csharp
builder.Services
    .AddScoped(sp => new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) })
    .AddFluentUIComponents();
```

В соответствии с [рекомендациями Microsoft](https://learn.microsoft.com/en-us/fluent-ui/web-components/integrations/blazor), необходимо добавить the composed scoped CSS file в head-раздел файлов "index.html", или "_Layout.cshtml":

```html
<link href="{PROJECT_NAME}.styles.css" rel="stylesheet" /> 
```

> В моём проекте, в файле "index.html" такая строка уже была: `<link href="SelectModel.styles.css" rel="stylesheet" />`

Для проверки работоспособности, в один из компонентов был добавлен следующий код:

```csharp
@using Microsoft.Fast.Components.FluentUI

<FluentCard>
    <h2>Hello World!</h2>
    <FluentButton Appearance="@Appearance.Accent">Click Me</FluentButton>
</FluentCard>
```

Страница с официальной документацией по FluentUI [доступна здесь](https://fluentui-blazor.net/).

> Использовать FluentSelect внутри FluentCard нельзя, т.к. у FluentCard есть чёткие границы, которые блокируют область отображения списка при его раскрытии.

При использовании шаблонного класса Option<T>, добавление

## Попытка полноценного решения задачи с раскрытием выпадающего меню

Списки select удалось успешно заменить на FluentSelect, но проблема с установкой и автоматическим переключением фокуса ещё не решена.

У компонента FluentSelect есть свойство Open, которое гипотетически можно было бы использовать для раскрытия списка, однако, это параметер:

```csharp
[Parameter]
public bool? Open { get; set; }
```

Оптимальным был бы полный уход от использования `@JSRuntime`.

К сожалению, имеющийся набор возможностей FluentSelect не позволяет добиться поставленной цели. Однако, используя механизм получения ссылок на элементы разметки - @ref, можно создать у конкретного органа управления идентификатор и получить доступ к этому элементу в JavaScript-коде:

```csharp
<FluentSelect Items=@Items
            OptionText="@(i => i.Text)"
            OptionValue="@(i => i.Value)"
            @ref="fluentSelect"
            @onchange="OnSelectionChanged" />
```

```csharp
@code {
    // ...

    private FluentSelect<Option<string>>? fluentSelect;

    public void SetFocus()
    {
        if (fluentSelect != null)
        {
            JSRuntime.InvokeVoidAsync("setFocusOnChildInput", fluentSelect.Id).GetAwaiter().GetResult();
        }
    }
}
```

```js
<script>
    window.setFocusOnChildInput = (id) => {
        const dropdown = document.getElementById(id);
        console.dir(dropdown);
    }
</script>
```

В функции setFocusOnChildInput уже можно пытаться работать с DOM, используя JavaScript.

> Следует заменить, что данный подход плох тем, что при создании каждого дочернего элемента SelectorList, будет создаваться функция setFocusOnChildInput(). Это легко проверить, если разместить перед ней `console.log('Определена функция setFocusOnChildInput');`. Т.е. в решение закладывается дополнительная, не вынуженная вычислительная нагрузка.

Но не следует сдаваться раньше времени - вариант со свойством Open вполне себе работоспособен. Нужно просто привязать его к свойству дочернего элемента SelectorList и функционал будет работать именно так, как нужно:

```csharp
<FluentSelect Items=@Items
    @bind-Open="isOpen"
/>
```

```csharp
@code {
    // ...

    private bool isOpen = false;

    public void SetFocus()
    {
        isOpen = true;
    }
}
```

Вот и всё - когда мы выбирает значение в одном списке, автоматически раскрывается следующий!

## Привязка реальных данных

В соответствии с условиями поставленной задачи, для загрузки в списки представляют собой дерево вариантов: в первом списке есть модели, у каждой модели - свой список поддерживаемых стран, для каждой пары модель+страна есть список исполнений (версий прошивки прибора).

Один из вариантов хранения информации о моделях - json-файл, который находится в папке "wwwroot" на сервере. Список моделей обновляется редко и скачивание статического файла - дешёвая операция. Этот вариант хорош тем, что при внесении изменений в список моделей, нам не нужно собирать и публиковать новую версию приложения - достаточно обновить только json-файл. Этот файл можно даже сформировать из базы данных в коде самого приложения.

Статический файл - это достаточно гибкое решение. Этот файл можно сохранять в кэше браузера и это снизить нагрузку, в том числе, и на сетевую подсистему.

Загрузить json-файл в Blazor-приложение можно следующим образом:

```csharp
@inject HttpClient Http

@code {

    // ...

    private Models.VendorDevices devices;

    protected override async Task OnInitializedAsync()
    {
        devices = await Http.GetFromJsonAsync<Models.VendorDevices>("data.json");
    }
}
```

Однако необходимо подготовить сами данные, а также разработать модель этих данных в Blazor-приложении.

Список моделей с разделением на vendor_name, product_name, и attribute_name уже существует в промышленно эксплуатирующейся базы данных. Но до этого момента нужно спроектировать модель данных для кода приложения. Как только модель будет разработана, можно будет создать генератор json-файла, соответствующий модели, из промышленных данных.

## Проблемы, которые потребовалось решить

Как результат, мы получили первый работающий вариант компонента выбора исполнения прибора. Ключевой код отдельного списка выглядит следующим образом:

```csharp
<FluentSelect Items=@Items
            OptionText="@(i => i.Text)"
            OptionValue="@(i => i.Value)"
            @bind-Open="isOpen"
            @onchange="OnSelectionChanged" />
@code {
    private void OnSelectionChanged(ChangeEventArgs e)
    {
        // Передаём родительскому элементу информацию о выбранном элементе списка
        if (e?.Value != null) {
            SelectEvent.InvokeAsync(e.Value.ToString());
        }
    }
}
```

Однако мы получаем несколько серьёзных проблем:

- FluentSelect не присылает событие OnSelectionChanged, если в списке находится только один элемент
- После первого выбора перестаёт работать автоматическое раскрытие списка выбора
- В некоторых списках очень много пунктов меню. Элементы таких списков не помещаются на экране. В решении для jQueryUI я делал custom-ный список, который выводил элементы в несколько колонок
- При нажатии кнопки "Reset" не сбрасывается текущий выбранных элемент списка (модели)

Решить проблему с OnSelectionChanged можно добавив обработчик onclick для каждого элемента списка:

```csharp
<FluentSelect TOption="string" @bind-Open="isOpen">
    @foreach (var item in Items)
    {
        <FluentOption Value="@item.Value" @onclick="() => OnItemClick(item)">
            @item.Text
        </FluentOption>
    }
</FluentSelect>

@code {
    private void OnItemClick(Option<string> item)
    {
        // Передаём родительскому элементу информацию о выбранном элементе списка
        SelectEvent.InvokeAsync(item.Value);
    }
}
```

Однако в таком варианте перестаёт работать выбор с клавиатуры.

Что делать со всеми этими проблемами - пока не понятно. Очевидно, что если парадигма пользовательского интерфейса разрабатываемого приложения расходится в FluentUI, то добиться желаемого поведения будет крайне сложно.

## Необходимые оптимизации

Поскольку в приложении может использоваться несколько разных ModelSelector-ом, необходимо разработать специализированный сервис, который будет загружать справочник моделей только один раз. Этот сервис должен быть реализован как Singleton с Lazy-загрузкой. Этот сервис должен быть внедрён в ModelSelector.

## Выводы

Парадоксально, но основная сложность не в отсутствии компонентной модели в браузерном JavaScript. Разработка кода в Blazor заняла сопоставимое, или даже большее время, чем разработка на JavaScript в компонентной модели jQueryUI. Однако код Blazor-приложения кажется более понятным, что в совокупности с Dependency Injection и LINQ, делает этот фреймворк более интересным, чем Vanilla JavaScript + jQuery и даже более интересным, чем React/Vue.js/Angular.
