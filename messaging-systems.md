# Системы доставки сообщений

В сложных web-приложениях, подсистема доставки сообщений имеет ключевое значение.

Ключевой книгой является "Enterprise Integration Patterns" by Gregor Hohpe и Bobby Woolf.

При выборе системы доставки сообщений для web-приложения, следует принять во внимание следующие элементы:

- Направление взаимодействия: **one-way only**, или обмен **request/reply**
- Цель сообщения, которая также определяет его контекст
- Синхронизация (timing) сообщения, т.е. сообщение отправляется/принимается синхронно (in-context), или асинхронно (out-of-context)
- Доставка сообщения, т.е. доставляется ли оно напрямую, или через брокера

## Message Broker

**Message Broker** - это временное хранилище данных между источником (sender) и получателем (receiver). Использование брокера добавляет "уровнень косвенности" между источником события и его получателем, что может упростить конфигурацию системы. Однако, использование broker-а создаёт и дополнительные проблемы:

- ухудшается латентность сетевого соединения
- добавляется ещё одна точка отказа
- при увеличении нагрузки, может потребоваться масштабирование broker-а

Основные протоколы, используемые при работе Broker-ов:

- [MQTT](https://mqtt.org/) - легковесный протокол обмена данными, спроектированный для machine-to-machine communications
- [AMQP](https://www.amqp.org/) - мощный протокол, open source альтернатива проприетарным middleware
- [STOMP](https://stomp.github.io/) - легковесный, text-based протокол

Все три протокола базируются на TCP/IP.

## WebSockets "из коробки"

Протокол WebSockets достаточно легко использовать в JavaScript-приложениях. Так, например, мы можем с минимальными усилиями создать чат-приложение в браузере. Для этого нам достаточно будет использовать следующий код ("index.js"):

```js
import WebSocket, { WebSocketServer } from 'ws';

const wss = new WebSocketServer({ port: 8080 });

wss.on('connection', function connection(ws) {
  ws.on('error', console.error);

  ws.on('message', function message(data) {
    console.log('received: %s', data);
	broadcast(data);
  });
});

function broadcast(msg) {
	for (const client of wss.clients) {
		if (client.readyState === WebSocket.OPEN) {
			client.send(msg);
		}
	}
}
```

В приведённом выше примере сервер создаёт WebSocket и при получении запроса на соединение, подписывается на получение сообщения. Когда сообщение будет получено, оно транслируется всем подписчикам (итерация по wss.clients).

HTML-страница, которая выступает в качестве клиента, может выглядеть следующим образом:

```html
<!DOCTYPE html>
<html>
	<body>
	Messages:
	<div id="messages"></div>
	<form id="msgForm">
		<input type="text" placeholder="Send a message" id="msgBox" />
		<input type="submit" value="Send" />
	</form>
	<script>
		const ws = new WebSocket('ws://127.0.0.1:8080');
		ws.onmessage = function (message) {
			const reader = new FileReader();
			reader.addEventListener("loadend", () => {
				const msgDiv = document.createElement('div');
				const text = String.fromCharCode.apply(null, new Uint8Array(reader.result));
				msgDiv.innerText = text;
				document.getElementById('messages').appendChild(msgDiv);
			});
			reader.readAsArrayBuffer(message.data);
		}
		const form = document.getElementById('msgForm');
		form.addEventListener('submit', (event) => {
			event.preventDefault();
			const message = document.getElementById('msgBox').value;
			ws.send(message);
			document.getElementById('msgBox').value = '';
		});
	</script>
	</body>
</html>
```

Когда пользователь нажмёт кнопку "Submit", сообщение будет отправлено серверу. Если сервер пришлёт какое-либо сообщение, оно будет декодировано из Blob-а, преобразовано в строку и добавлено в область отображения полученных сообщений.

Приведённый выше пример не учитывает различные кодировки символов и, вместо киррилического текста, например, может выводиться "мусор". Кроме этого, данная реализация не восстанавливает соединение с сервером при его потере. Польза библиотеки [Socket.io](https://socket.io/) в том, что она скрывает неудобства базового API WebScoket.

## Redis, как брокер запросов

Предположим, что для увеличения количества пользователей системы, принято решение создать несколько экземпляров серверов. Заметим, что каждый сервер работает только с часть пользователей, которые были зарегистрированы именно на нём. Возникает вопрос, а как реализовать широковещательную рассылку сообщений, в которой пользователь, зарегистрированный на одном сервере отправляет сообщение пользователям, зарегистрированных на всех остальных серверах в системе? Ответ состоит в том, что нам необходимо обеспечить широковещательную рассылку сообщений между серверами. Возможно два основных варианта: используется вспомогательный брокер запросов, через который осуществляется обмен сообщениями, либо сервера объединяются, используя соединение все со всеми.

**Redis** - это вариант _in-memory_ хранилища сообщений, поддерживающий шаблон Pub/Sub, что позволяет реализовать первый из двух вариантов.

В апреле 2024 года, официальная страница [Redis](https://redis.io/) блокировала доступ пользователей из России.

В Redis реализована возможность использовать шаблон проектирования Pub/Sub. Приложение, использующее Redis открывает два канала (один на подписку и один на публикацию):

```js
import Redis from 'ioredis';

const redisSub = new Redis();
const redisPub = new Redis();
```

Публикация сообщений выглядит приблизительно так:

```js
redisPub.publish('chat_messages', msg);
```

В приведённой выше строке, 'chat_messages' - идентификатор подписки, или, другими словами, имя группы для публикации.

Подписка на события выглядит следующим образом:

```js
redisSub.subscribe('chat_messages');
redisSub.on('message', (channel, msg) => {
	// Рассылаем сообщения клиентам, подключенным к данному экземпляру приложения
	for (const client of wss.clients) {
		if (client.readyState === WebSocket.OPEN) {
			client.send(msg);
		}
	}
});
```

Одна из причин, по которой имеет смысл использовать Redis, состоит в том, что мы можем использовать одну копию Broker-а совместно с несколькими экземплярами приложений Node.js. Это позволяет достаточно гибко обеспечивать горизонтальное масштабирование системы. Мы можем поднять ещё несколько instances приложения на Node.js, каждое из которых будет подписано сообщения передаваемые через Redis, и каждый из этих instances, в свою очередь, будет рассылать эти сообщение своим WebSocket-клиентам.

Ввиду однопоточности Node.js, эффективная утилизация многоядерных процессоров потребует запуска нескольких экземпляров приложения, которые будут доступны на разных портах. Балансировщик нагрузки (sticky load balancer) привяжет каждого из клиентов к своей копии сервера и сервер будет транслировать своим клиентам сообщения от всех других клиентов в системе, через единственную копию Redis.

## Peer-to-peer взаимодействие, посредством ZeroMQ

В случае использовать Peer-to-peer взаимодействия, каждый сервер должен открыть один порт для подключения всех других серверов к нему (publish) и сам должен подписаться на сообщения всех остальных серверов (subscribe). Например, при запуске трёх экземплятров сервера следует выполнить три команды:

```js
node index.js --http 8080 --pub 5000 ---sub 5001 --sub 5002
node index.js --http 8081 --pub 5001 ---sub 5000 --sub 5002
node index.js --http 8082 --pub 5002 ---sub 5000 --sub 5001
```

Для создания канала публикации сообщений, может быть использова следующий код:

```js
import zmq from 'zeromq';

let pubSocker;
pubSocket = new zmq.Publisher();
await pubSocket.bind(`tcp://127.0.0.1:${yargs.argv.pub}`);
//...
pubSocket.send(`chat ${msg}`);
```

Подписка и получение сообщений от нескольких серверов может выглядеть так:

```js
async function initializeSockets() {
	const subSocket = new zmq.Subscriber();
	const subPorts = [].concat(yargs.argv.sub);
	for (const port of subPorts) {
		subSocket.connect(`tcp://127.0.0.1:${port}`);
	}
	subSocket.subscribe('chat');
	for await (const [msg] of subSocket) {
		// Обрабатываем сообщение от другого сервера
	}
}

// Здесь мы вызываем асинхронную инициализацию socket-а, но не ждём
// её завершения
initializeSockets();

// Далее мы запускает WebSockets-сервер и реализуем функционал рассылки сообщения своим клиентам
```

Достаточно необычно выглядит следующая строка:

```js
for await (const [msg] of subSocket) {
```

На самом деле, subSocket является генератором будет работать бесконечно и асинхронно.

## Гарантированная доставка сообщений с использованием очередей (MQ)

Очереди сообщений (MQ) являются очень важной частью приложений в которых критичным является гарантированная доставка сообщений. Гарантированность обеспечивается тем, что сообщения храняться в **persistance**, т.е. постоянном хранилище, до тех пор, пока не истечёт их срок годности, либо пока клиент не заберёт их. Благодаря постоянному хранению сообщений и потверждению доставки, клиент может упасть, перезагрузиться, но когда он восстановит свою работу, то заберёт сообщения и обработает их.

Существует понятие **durable subscriber** - подписчик который надёжно получает все сообщения, даже если подписчик был недоступен, когда сообщение было отправлено.

Различаются разные **delivery semantic** - категории обработки сообщений: At most once, At least once, Exactly once.

Одним из наиболее распространённых Open-Source протоколов очередей является **AMQP**. Одна из наиболее популярных реализаций AMQP - [RabbitMQ](https://www.rabbitmq.com/tutorials/amqp-concepts).

В качестве альтернативы очередям сообщений могут рассматриваться потоки, В частности: [Apache Kafka](https://kafka.apache.org/), [Amazon Kinesis](https://aws.amazon.com/ru/kinesis/) и **Redis Streams**.
