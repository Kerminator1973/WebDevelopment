# Микро-сервисная архитектура

Термин **микро-сервисы** впервые появился в 2011 году. В 2014 году Martin Fowler и James Lewis опубликовали [статью Microservices](https://martinfowler.com/articles/microservices.html). Эта статья быстро стала стандартом де-факто для разработчиков микро-сервисных архитектур.

Характеристики (атрибуты) микро-сервисов:

- Componentization via Services
- Organized Around Business Capabilities
- Products not Projects
- Smart Endpoints and Dumb Pipes
- Decentralized Governance
- Decentralized Data Management
- Infrastructure Automation
- Design for Failure
- Evolutionary Design

## Componentization via Services

Модульный дизайн – это всегда хорошая идея.

Компоненты – это части, которые при совмещении (*composed together*) образуют программное обеспечение. Каждый компонент отвечает за специфическую функцию системы.

В микро-сервисах предпочтительным является использование *Services*, а не *Libraries*. При этом, внутри самого сервиса могут быть использованы библиотеки. Важно то, что сущность, рассматриваемая как **компонент системы** должна быть сервисом, а не библиотекой.

## Organized Around Business Capabilities

В традиционных проектах команды имеют горизонтальную ответственность: пользовательский интерфейс, API, базы данных, бизнес-логику, и т.д. В монолитных приложениях чаще сего именно такое разделение даёт максимальных эффект.

Но в микро-сервисной архитектуре сервисы строятся вокруг бизнес-потребностей. Сервис решает какую-то конкретную особенность и разрабатывается одной командой, которая отвечает за все аспекты сервиса (пользовательский интерфейс, API, базы данных, бизнес-логику).

Ключевой вопрос: как мы понимаем, что вот здесь один сервис заканчивается и начинается другой? В микро-сервисной архитектуре мы идём от **business capabilities**. Например, в бизнесе есть разные бизнес-процессы: логистика, управление корзиной покупок, доставка товара клиентам, сопровождение клиентов – именно они и определяют границы сервисов.

## Products not Projects

В традиционных проектах, целью является доставка заказчикам работающего кода. Вовлечённость бизнеса в процесс разработки является минимальной (*no lasting relationship with the customer*). Обычно с клиентами общается только project manager и аналитик. Часто, после выпуска продукта, проектная команда уходит по другим проектам и больше не работает в бизнес-направлении.

В микро-сервисной архитектуре целью является доставка заказчикам работающего продукта. Если код оказывается менее элегантным, но это приводит к лучшему продукту, то так и должно быть.

Продукт должен сопровождаться и требует близкого взаимодействия с заказчиком всех членов команды.
Команда отвечает за микро-сервис после того, как он передан заказчику.

Werner Vogels, AWS CTO: "*You build it, you run it*".

## Smart Endpoints and Dumb Pipes

Микро-сервисы используют уже существующие web-протоколы (http/https). Часто используется REST API. В последние годы также активно используются такие протоколы как **GraphQL** и **gRPC**.

## Decentralized Governance

В микро-сервисах каждая команда принимает свои собственные решения по каждому из пунктов. Каждая команда полностью отвечает за свой сервис: "*You build it, you run it*". Этот подход позволяет принимать для каждого сервиса оптимальные технические решения. Это представляется возможным благодаря природе микро-сервисов со слабыми связями.

## Decentralized Data Management

В традиционных системах используется одна база данных, в которой все компоненты хранят свои данные.

В микро-сервисах каждый сервис имеет свою собственную базу данных. Говоря про разные базы данных, в первую очередь имеются в виду разные типы баз данных: SQL, NoSQL, кэширующие, in-memory, и т. д.

Самая большая проблема микро-сервисной архитектуры – это распределённые транзакции. Они требуют применения специализированных сложных алгоритмов синхронизации состояний и обеспечения транзакционности, что критически усложняет систему.

Дублирование данных – это всегда плохая идея.

Вы, как архитектор не должны настаивать на жёстком следовании данному принципу - он наиболее противоречивый из всех принципов микро-сервисной архитектуры.

## Infrastructure Automation

Рекомендуется использовать:

- Автоматизированное тестирование
- Автоматизированное развертывание

Циклы разработки должны быть очень короткими.

Есть множество разных инструментов автоматизации: Azure DevOps, GitLab, Jenkins.

## Design for Failure

При использовании микро-сервисов используется множество процессов и очень большой сетевой трафик. Это значит, что очень много что может пойти нет так.

Код должен предполагать, что сбои могут случаться и должен обрабатывать такие ситуации gracefully. Например, если сервис использует какой-то другой сервис, следует предполагать, что сервис не будет доступен и при его отсутствии должны быть приняты компенсационные меры, такие как, например, повторный вызов (Retry), отложенное выполнение операции, и т.д.

Не обработанные исключения (unhandled Exception) являются недопустимыми.

Так же система логирования должны быть исключительно мощной, а все система должна подвергаться мониторингу.

Мониторинг, в том числе, должен анализировать объем памяти и загрузку процессоров каждого сервиса. Примеры систем: Azure Monitor, Application Insights, Kubernetes.

## Evolutionary Design

- Переход на микро-сервисную архитектуру должен быть постепенным (эволюционным)
- Не нужно разламывать существующую систему на части
- Начинайте с малого и развивайте каждую часть отдельно

## Критика микросервисной архитектуры

Рекомендуется ознакомиться со статьёй [Смерть от тысячи микросервисов](https://habr.com/ru/articles/779362/) by [Andrei Taranchenko](https://renegadeotter.com/2023/09/10/death-by-a-thousand-microservices). Ключевая идея статьи: количество проблем которые создают микросервисы значительно превышают бенефиты в подавляющем большинстве случаев.

Ещё в одной статье [Миграция микросервисной архитектуры на API Gateway](https://habr.com/ru/articles/765944/) by _EmotionTigran_, фокус на следующих проблемах микросервисной архитектуры:

- безопасность
- сложность разработки
- скорость разработки
- дублирование функционала

Для решения проблемы предлагается сделать единый фасад, используя API Gateway.
