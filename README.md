# Что такое web-разработка

Под термином **web application** часто подразумевают приложение, доступ к которому доступен через интернет-браузер. Пользователь запускает Google Chrome, Firefox, или Microsoft Edge, вводит адрес этого приложения (URL), браузер подключается к серверу, загружает какие-то данные и начинает их обрабатывать, отображая результат в своем окне.

Сервер формирует и передаёт браузеру набор данных (HTML-верстка, каскадные таблицы, клиентские js-файлы, дополнительные данные), браузер отображает их и динамически корректирует отображение (исполняя клиентские js-файлы). Технологический стек, используемый для разработки приложения на сервере и отображения информации в браузере, могут быть разными. Типы решаемых задач так же различаются: сервер получает данные из разных источников (базы данных, файлы с шаблонами, другие сервера) и генерирует новые данные в форматах, понятных браузеру. Браузер обрабатывает файлы с описанием разметки, стилистического оформления и инструкции по динамическому изменению отображения и управляет выводом.

Задачи, связанные с работой сервера принято называть **Back-End** Development, а задачи, связанные с браузером – **Front-End** Development.

Содержимое статьи:
- Технологии [Front-End](#frontend)
- Альтернативы JavaScript: [WebAssembly](#webassembly), [TypeScript](#typescript)
- [Основные проблемы](#problems) web-приложений
- [Решение проблем](#frameworks) при помощи фреймворков
- [Bundler-ы](#bundler). WebPack и другие
- [Информационная безопасность](#security)
- Типы команд разработчиков и [архитектурных шаблонов](#teams)
- Технологии [Back-End](#backend)
- Особенности технологического стека [Node.js](#nodejs)
- Особенности технологического стека [ASP.NET Core](#aspnet)
- Особенности технологического стека [Java](#java)
- [Serverless Backend](#serverless)
- Архитектурые шаблоны [CRUD и RESTful](#crud)
- Шаблон [MVC](#mvc)
- Шаблон [CQRS](#cqrs)
- [Reverse Proxy](#reverse_proxy): nginx, Apache и IIS
- [Инструментальные средства](#tools) для web-разработки
- [Дополнительно](#extra)

# Технологический стек

Выбор технологического стека критически влияет на разработку программного обеспечения – именно этот выбор закладывает технологические ограничения, которые возникнут в будущем. Поменять технологический стек, на практике, крайне сложно и этот выбор определяет наборы «костылей», которыми будет обладать продукт, а также стоимость его сопровождения и развития.

<a name="frontend"></a>
## Технологии Front-End

При разработке Front-End часто используется принцип, называемый Separation of Concerns. В соответствии с этим принципом, структура данных описывается посредством HTML, за стилистическое оформление определяется каскадными таблицами **CSS**, а динамическое поведение определяет JavaScript-код.

В современных web-приложения HTML является хранилищем структурированных данных - это **документ с иерархической структурой** (дерево), у каждого элемента которой есть:

1. Уникальный идентификатор (id)
2. Набор классов (class) к которым относится этот элемент
3. Тип (tag name)
4. Набор дополнительных атрибутов
5. Содержимое - человеко-читаемый текст

Всё **стилистическое оформление** указывается в каскадных таблицах. Это относится не только к шрифтам и цвету, но и к взаимному расположению элементов, а также к **векторной графике** и **анимации** (transitions). В современном HTML уже нет тэгов TABLE, TD, TR и подобных - взаимное расположение элементов описывается посредством **Flexbox** ([шпаргалка](https://tpverstak.ru/flex-cheatsheet/)).

[Сайт-пример](http://www.csszengarden.com/) использования CSS с объяснениями, является сопровождением книги «The Zen of CSS Design: Visual Enlightenment for the Web».

С CSS связано понятие **CSS Selector** - способ поиска DOM-элемента на странице для применения к нему стилистического оформления. [Статья](https://code.tutsplus.com/ru/tutorials/the-30-css-selectors-you-must-memorize--net-16048) об селекторах. Ещё одна [статья](https://developer.mozilla.org/ru/docs/Web/CSS/Specificity) о том, как браузер применяет стили для комплексных селекторов. Для наиболее сложных случаев рекомендуется использовать специальный [инструмент для определения specificity](https://specificity.keegan.st/).

Отдельная большая задача - [выбор совместимых шрифтов](https://www.cssfontstack.com/), доступность которых на разных операционных системах может отличаться. Google рекомендует хранить шрифты на сайте и загружать их вместе с другими артефактами. Также Google предоставляет бесплатную коллекцию шрифтов [Google Fonts](https://fonts.google.com). [Статья](http://css-tricks.com/snippets/css/using-font-face/) описывает загрузку шрифтов в web-приложении.

Существуют специализированные наборы CSS-стилей (а также дополнительного JavaScript-кода) значительно упрощающие дизайн пользовательского интерфейса web-приложений. Такие наборы оформляются в виде библиотеки и часто содержат:

1. Grid-систему, упрощающую размещение элементов пользовательского друг относительно друга
2. Механизмы отображения модальных окон
3. Responsive design - автоматическую адаптацию внешнего вида приложений под фактическое разрешение монитора/экрана планшета и мобильного телефона, с учётом ориентации
4. Дополнительные наборы widgets 

Наиболее популярной библиотекой является [Twitter Bootstrap](http://getbootstrap.com/). Популярная альтернатива - [Semantic UI](https://semantic-ui.com/), у которой есть адаптация под React.

В крупных проектах возникает проблема избыточных CSS, которая влияет как на объём передаваемых по сети данных, так и на простоту сопровождения web-приложения. Для решения проблемы можно использовать специализированные пред-процессоры SaSS/SCSS, [LESS](http://lesscss.org/), [Stylus](https://stylus-lang.com/) и другие. [Syntactically Awesome Stylesheets (SASS)](http://sass-lang.com/) является одним из наболее популярных инструментов для описания каскадных таблиц с элементами языка программирования. Пример определения каскадных таблиц на **SCSS** - новой версии SaSS:

```sass
$font-stack:    Helvetica, sans-serif
$primary-color: #333
body
    font: 100% $font-stack
    color: $primary-color
```

**Динамическое поведение** (JavaScript), преимущественно отвечает за взаимодействие с сервером. В случае применения парадигмы Single Page Application (**SPA**), значение JavaScript значительно шире - он начинает управлять состоянием приложения, переходами между логическими экранами, обеспечивает информационную безопасность, и т.д.

Из-за использования пользователями разных браузеров и их разных версий, существует проблема технологической фрагментации - какие-то технологические возможности браузера могут быть недоступны конкретному пользователю. Чтобы решить подобные проблемы обычно используются вспомогательные инструменты/библиотеки. В течение долгого времени, доминировала библиотека [jQuery](https://jquery.com/), но в последние годы популярность jQuery снижается. Основной проблемой jQuery считаются высокие дополнительные накладные операционные расходы (это, например, проверка типа селектора для подбора соответствующей реализации алгоритма поиска DOM-элементов). Также загрузка jQuery не бесплатна - размер библиотеки составляет от 200 до 500 килобайт. Вместе с тем, снижение популярности происходит скорее не из-за jQuery как таковой, а из-за перехода от Multi-Page Applications к Single-Page Applications. SPA даёт огромное количество потенциальных преимуществ (которые ещё нужно реализовать в коде), например:

1. Справочник скачивается один раз при запуске приложения, а не при загрузке каждой страницы
2. SPA часто разрабатываются в декларативном стиле и scope переменных ощутимо меньше захламляется

В некоторых случаях, разработчики используют ["чистый" JavaScript](http://youmightnotneedjquery.com/), т.н. *Vanilla JavaScript*. Для проверки применимости некоторой функции в конкретном браузере может быть использован ресурс [CanIUse](https://caniuse.com/).

В последние годы появляется много приложений поддерживающих **The WebSocket Protocol**. Его ключевое отличие от http состоит в том, что WebSocket является двунаправленным протоколом с постоянно установленным соединением. Это значит, что при необходимости отправки сообщения не нужно выполнять handshake, а сервер может отправить сообщение любому из активных web-приложений, исполняющихся в браузере, в произвольный момент времени. Этот протокол позволят динамически обновлять HTML-контент со стороны сервера. Наиболее популярными библиотеками для работы с WebSocket являются [Socket.io](https://socket.io/) и [SignalR](https://github.com/SignalR/SignalR).

## Альтернативы JavaScript

<a name="webassembly"></a>
### Выполнение кода в браузере

Основными ограничениями JavaScript на клиентских компьютерах считаются: однопоточность и тот факт, что JavaScript - интерпретируемый язык программирования. Влияение этих факторов может быть минимальным благодаря тому, что многопоточность поддерживается в runtime и благодаря этому, например, клиентский JavaScript может выполнять несколько http(s) запросов одновременно. То же самое можно сказать и о производительности - до того момента, пока JavaScript не используется для выполнения задач с высокой вычислительной нагрузкой (они выполняются Runtime, либо посредством ActiveX, либо посредством кода в host-приложении), проблем с производительностью быть не должно.

Если же необходимо выполнить высокую вычислительную нагрузку непосредственно в клиентском коде, альтернативой JavaScript может выступать технология **WebAssembly**. Эта технология поддерживается современными браузерами и существуют инструменты, которые позволят разрабатывать соответствующий клиентский код. В первую очередь это [Microsoft Blazor](https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor) и [Qt for WebAssembly](https://doc.qt.io/qt-5/wasm.html).

<a name="typescript"></a>
### Трансляция кода в JavaScript

Поскольку разные браузеры поддерживают разные версии JavaSctipt, раньше разумной стратегией являлось использование версии языка поддерживаемого максимально большим количеством браузеров, т.е. работало правило: "Чем старее JavaScript, тем он лучше совместим с браузерами". По мере взросления технологий web-разработки, стали появляться транспайлеры - инструменты конвертирующий код на одном языке программирования в соместимую с целевыми браузерами версию JavaScript. Одним из наиболее популярных языков для которого есть эффективный транспайлер является [TypeScrypt](https://www.typescriptlang.org/).

Достоинства TypeScrypt:

* Строгая типизация (Strong Typing)
* Является объектно-ориентированным (Object Orientated)
* Удобен для поддержки IntelliSense
* Поддержка модификаторов доступа (Access Modifiers)
* Поддержка будущих функций JavaScript (Future JavaScript features)
* Отслеживает глупые ошибки в процессе разработки кода
* Поддерживается большим количеством 3rd party библиотек
* Прост в изучении, если вы уже знаете JavaScript

Недостатки TypeScript:
* Код становится более объёмным
* Некоторые библиотеки не поддерживают TypeScript и для них требуется разрабатывать wrapper-ы
* Strict mode в JavaScript действительно очень _strict_ (жестокий)

<a name="problems"></a>
## Основные проблемы web-приложений

Одним из наиболее критичных ограничений, связанных с работой web-приложений является канал связи между клиентским компьютером (браузером) и сервером. На пользовательский опыт крайне негативно влияют: **полоса пропускания** (какой объём данных может быть загружен за единицу времени) и **латентность** сети (как быстро будет получен ответ на запрос, без учёта потерь на подготовку ответа сервером).

Чтобы обеспечить конфортное использование приложения пользователем, необходимо минимизировать объём передаваемой информации и делать это только при необходимости.

Различают два подхода в организации пользовательского интерфейса: [server-side rendering](server-side-rendering.md) и [client-side rendering](client-side-rendering.md). В первом случае, основная работа по формированию пользовательского интерфейса осуществляется на сервере, т.е. максимально близко к базам данных. Во-втором случае, сервер нагружается существенно меньше, а формирование пользовательского интерфейса осуществляется браузером на основании накопленных (или уточнённых у сервера) данных. Выбор в пользу использования того, или иного подхода зависит от особенностей конкретной задачи.

Чтобы уменьшить количество запросов на сервер (в том числе, статических данных) используются:

1. Bundling - объединение разнородных ресурсов в один (или несколько) загружаемый файл. Пример объединения нескольких SVG-файлов в один, доступен [здесь](svg-bundling.md)
2. Minifying - реструктуризация JavaScript/CSS-кода с целью устранения избыточностей. Из кода могут быть удалены комменатрии, переменные могут быть переименованы
3. Client Side Caching - кэширование данные на стороне клиента

К проблемам разработки web-приложений могут быть отнесены: различные функциональные возможности клиентских браузеров, см. [CanIUse](https://caniuse.com/), а также высокая сложность клиентского JavaScript-кода. Часто, в одном js-файле реализован функционал имеющих отношения к десяткам разных органов управления, никак не связанных между собой. Всё это сказывается на сложность сопровождения Front-End и надежности приложения в работе.

Также значимой проблемой может быть использование разных версий JavaScript как в браузере, так и на серверной стороне. Похожая проблема существует и при использовании разных версий Node.js, которые поддерживают разные версии и свойства ECMAScript (JavaScript). Возможное решение проблемы - применение транспайлинга кода, т.е. его трансляции в JavaScript-код, совместимый с целевой системой.

В случае, если web-приложение используется глобально, могут возникать различные проблемы доступа к сайту, в частности, долгое время загрузки артефактов из-за большого количества router-ов между пользователем и сервером. Чтобы решить эту проблему используются **Content Distribution Networks (CDN)** - сети кэширующих серверов. Услуги CDN-провайдеров могут быть платными для владельцев web-сайтов.

Потенциально критичная проблема - слабое управление кэшированием объектов, в частности, javascript-кода. При публикации новой версии приложения, при загрузке нового HTML-файла может использовать JavaScript-код из кэша, что может привести к фатальным ошибкам в коде. Для решения проблемы, URL для загрузки компонента (js, css) может содержать либо версию сборки, либо случайное значение, обновляемое при публикации новой версии.

<a name="frameworks"></a>
## Решение проблем при помощи фреймворков

Ключевым направлением развития web-разработки является использование фреймворков и библиотек помогающих в разделении web-приложения на изолированные, простые в сопровождении компоненты. Чаще всего подобные библиотеки реализуют подход под названием **Shadow DOM**, минимизируя влияние медленного механизма Document-Object Model (DOM) на пользовательский опыт. Ещё одной важной состовляющей фреймворков является встроенная поддержка инструментов Bundling-а и минификации кода.

На данный момент, доминирующими решениями являются:

1. Библиотека [React](https://ru.reactjs.org/) от Facebook. React - это ядро. Для создания полноценных приложений нужны вспомогательные *3d party* компоненты. [Пример](reactappsample.md) простейшего React-приложения.
2. Framework [Angular](https://angular.io/) от Google. Бывший лидер. Проблемы с SEO. Особенность - все необходимые компоненты уже встроены во Framework
3. [Vue.js](https://vuejs.org/), Легковесный. Особенно популярный у китайский товарищей. *Evan You* - один из разработчиков Angular.js
4. [Svelte](https://svelte.dev/). Особенность - предварительная компиляция кода с целью ускорить время старта и общую производительность web-приложения

В простых приложениях могут быть использованы mini-frameworks, которые использую Shadow DOM для решения одной специализированной задачи, например, для управления отображением, фильтрацией, сортировкой и поиском данных в таблице. Пример такой специализированной библиотеки - [DataTables.net](https://datatables.net/).

Ключевые термины:

1. **Transpiler** - инструменты, преобразующие современный код ([TypeScript](https://www.typescriptlang.org/)/[CoffeeScript](https://coffeescript.org/)) в совместимый с конкретной целевой платформой
2. [Babel](https://babeljs.io/) - одна из наиболее популярных реализаций транспайлеров
3. **Polyfill** - JavaScript-код компенсирующий отсутствие в конкретной реализации JavaScript конкретных функциональных возможностей. Чаще всего применение polyfills приводит к некоторому падению производительности приложения. Дополнительная информация доступна [здесь](http://kangax.github.io/compat-table/es6/).
4. **Bundle** - единица доставки (distribution), в которую могут быть включено несколько файлов
5. **Bundler** - инструмент объединения файлов с JavaScript-кодом в один, или несколько файлов (bundles). Наиболее популярный bundler - [WebPack](https://webpack.js.org/). Поддерживает огромное количество plug-ins
6. **Preset** - готовые наборы предустановок для наиболее популярных особенностей языка 
7. **HTML Preprocessor** - компонент, осуществляющий генерацию HTML-верстки, используя шаблоны документов

<a name="bundler"></a>
### Bundler. WebPack и другие...

Использование **Bundler** важно, поскольку этот инструмент позволяет настроить среды отладки и промышленной сборки должным образом. Конфигурация Bundler-а определяет:

1. какой транспайлер будет использован, например: Babel (React), или TypeScript (Angular)
2. какая версии ECMAScript является целевой
3. какие полифилы должны быть подключены при выполнении кода в браузере
4. какой инструментарий должен быть запущен при отладке кода (**nodemon**?)
5. какие файлы и в какие bundles должны быть упакованы и каким loader-ом. Какой следует использовать алгоритм сжатия (**gzip**, **brotli compression**) и утилиту минификации
6. каким образом должны быть сформированы имена клиентских файлов (css и js) для того, чтобы при их изменении на сервере, браузер не забрал ранее локально закэшированные файлы

Чаще всего инструментальные средства (CLI) конкретных фреймворков создают конфигурационные файлы для Bundler-а (часто, для WebPack 4).

Считается, что WebPack является мощным, но сложным в использовании инструментом, поскольку он появился одним из первых и включает большое количество _legacy_ технологий. Основные претензии - сложный, многоуровневый файл "webpack.\*.js", в котором активно используются регулярные выражения, а синтаксис настроек подключаемых компонентов (plug-ins) слабо структурирован.

В качестве альтернатив рассматриваются:

* [Parcel](https://parceljs.org/). Разработчики продукта сфокусировались на _zero configuration_. Простота достигается посредством большого количества default-ных значений. Недостаток: подходит только для простых проектов
* [Rollup](https://rollupjs.org/guide/en/). Статья [Why I use Rollup, and not Webpack](https://medium.com/@PepsRyuu/why-i-use-rollup-and-not-webpack-e3ab163f4fd3) за авторством Paul Sweeney. Разработчики так же стремятся реализовать подход zero configuration, что достигается благорадя использованию ES Modules, нативно поддерживаемому современными браузерами
* [Vite](https://vitejs.dev/)
* [Snowpack](https://www.snowpack.dev/). Статья [Web Developers: Use Snowpack instead of Webpack](https://javascript.plainenglish.io/web-developers-use-snowpack-instead-of-webpack-70e7b04f7853) за авторством Morgan Page

Вместе с тем, WebPack 5 может быть лишён многих, озвучиваемых сообществом, недостатков: https://webpack.js.org/blog/2020-10-10-webpack-5-release/

В некоторых проектах не удаётся применять полноценный Bundler и в этом случае можно применить инструмент минификации. Пример подобной утилиты - [Uglify-JS](https://www.npmjs.com/package/uglify-js).

Установить Uglify-JS можно локально:

```
npm install uglify-js
```

Допустим, что мы хотим выполнить минификацию файла "device.js" и сохранить результат в "device.min.js". В этом случае, команда может выглядеть следующим образом:

```
node d:\Sources\RUFServerLite\node_modules\uglify-js\bin\uglifyjs d:\Sources\RUFServerLite\public\devices.js -o d:\Sources\RUFServerLite\public\devices.min.js
```

Параметры `-c` (compress) и `-m` (mangle names) позволяют применять дополнительную оптимизацию JavaScript-кода.

На практике объём типового JavaScript-файла удаётся уменьшить в три раза.

<a name="security"></a>
## Информационная безопасность

При разработке web-приложений, чаще всего приходится решать задачи, связанные и информационной безопасностью, к которым относятся:

1. Аутентификация пользователя
2. Управление сессионной информацией
3. Подтверждение достоверности сервера и клиента

В различных технологических стеках используются разные инструменты, но схожие подходы. Говоря об аутентификации пользователя критически важным является хранение на сервере пароля пользователя как **хэш-кода**, а не plain text. Это связано с тем, что подавляющее число пользователей используют одни и те же **credentials** (пару логин/пароль). Соответственно, при компрометации базы с пользовательскими данными, злоумышленники пробуют похищенные credentials на множестве крупных сайтов и это часто приводит к взлому аккаунтов, в том числе, в банковских системах.

При вычислении хэш-кода должно подмешиваться случайное значение (часто такое значение называется *salt*, и хранится в отдельном поле записи о пользователе), а сама операция может состоять из нескольких операций вычисления хэша (*the number of rounds*, часто устанавливают в значение восемь).

Важно знать, что вычисление хэш-кода является односторонней криптографической операцией (*one-way algorithm*), что означает, что можно вычислить хэш-код для пароля, но нельзя вычислить пароль по хэш-коду. Примером алгоритма для вычисления хэш-кода является **SHA512**.

Для управления сессионной информацией чаще всего используется JSON Web Token (**JWT**) - блок данных, которых состоит из заголовка, полезной нагрузки и хэш-кода (электронно цифровой подписи). После проверки пароля, сервер формирует JWT и возвращает его клиенту (JavaScript-коду исполняемому в браузере). Клиентское приложение сохраняет этот код в localStorage браузера и при каждом следующей запросе на сервер добавляет его в MIME-заголовок https-запроса. Сервер проверяет созданным его же ключами JWT и либо выполняет, либо отклоняет запрос. Чаще всего у JWT установлен период действия, при истечении которого JWT считается нелегитимным. Сервер может передать клиенту новый JWT, если посчитает это возможным. В рамках подхода считается, что злоумышленник не сможет получить доступ к localStorage конкретного пользователя.

Для того, чтобы повысить безопасность системы, часто используют связку из token-а и refreshToken-а. Первый из них обладает коротким временем жизни (например, в одну минуту), а второй может быть годным, например, в течение недели, но является одноразовым. Как только token становится expired сервер возвращает приложению код 401 и клиентское ПО запрашивает у сервера обновление токена (по специальному URL), предоставляя refreshToken. Если злоумышленник перехватит token, этого токена хватит всего на одну минуту. Если будет украден и «refreshToken», то пользователя выкинет из системы и он(а) поймёт, что безопасность была нарушена. При повторном логине, украденный «refreshToken» перестанет действовать.

Обычно, сервер возвращает token в ответе на запросы Login/Register в JSON формате, а затем клиентское ПО помещает его в поле «Bearer» в http-заголовке всех последующих запросов. RefreshToken – это значение, которое передаётся через cookie и является идентификатором в базе данных, и который позволяет понять серверу, что генерация нового токена является допустимой.

Для проверки достоверности клиента и сервера может осуществляться односторонняя, или двухсторонняя аутентификация. Для проведения аутентификации используется **ассиметричная криптография**. Ключевые слова: сертификаты, корневой сертификат, SSL, TLS, Cipher Suite.

<a name="teams"></a>
# Типы команд разработчиков и архитектурных шаблонов

Web-программирование это комбинация ПО работающего на клиентском компьютере (чаще всего - код исполняется браузером) и серверного ПО. Различают несколько архитектурных шаблонов:

**Monolith** - в этом типе архитектур, программисты обычно являются _full-stack developers_. Они разрабатывают и front end, и back end. Такой тип команд считается наиболее ортодоксальным.

**FE/BE** - разные группы инженеров отвечают за разработку front end и back end. Специализация позволяет создавать более сложные системы, но ценой больших затрат на команду и командное взаимодействие.

**Microservices** - в этом подходе система разделяет на целый ряд связанных, но слабо сцепленных сервисов, каждый из которых может разрабатываться отдельной командой. В этом случае, логика системы в целом может быть очень сложной. Простота интеграции достигается в том случае, если декомпозиция сервисов оказалось удачной (_fine-grained_).

**Micro frontends** - разные команды занимаются не только разными сервисами, но и разными задачами в области front-end. Этот подход способен ещё больше повысить сложность системы в целом.

В статье [What Are Micro Frontends? Is It Even Necessary to Use Them?](https://medium.com/better-programming/what-are-micro-frontends-is-it-even-necessary-to-use-them-f1393d65ef2f) Harsha Vardhan эта тема рассматривается подробнее.

<a name="backend"></a>
## Технологии Back-End

Посмотреть информацию о том, какие технологические стеки выбирают разные IT-компании можно на сайте [StackShare](https://stackshare.io/).

Первым узлом, который обрабатывает запросы браузера является web-сервер, который выполняет маршрутизацию запросов на сервер приложений. Разработчик web-приложения использует  некоторый Framework интегрированный с сервером приложений. Framework, обычно, содержит инструментальные средства для взаимодействия с базами данных, или другими сетевыми сервисами. Ниже приведены примеры технологических стэков для разработки Back-End.

|         Framework         |   Язык     |                    Web-сервер                    | База данных    |
|:-------------------------:|:----------:|:------------------------------------------------:|----------------|
| ASP.NET Core 3            |     C#     |       Internet Information Server и Kestler      | SQL Server     |
| Node.js                   | JavaScript |                Express.js, Koa.js                | mongoDB, Redis |
| Django, Flask             |   Python   |                                                  | MySQL          |
| Spring, Struts, Hibernate |    Java    | Nginx/Apache с Tomcat, Glassfish, Wildfly, Jetty | Oracle         |

Задача Framework состоит в том, чтобы доставить http-запрос в функцию, наиболее подходящую для его обработки. Для этого осуществляется настройка таблиц маршрутизации (Routing) в web-приложении. Основные различия между фреймворками состоят в том, какая именно модель используется для описания таблиц маршрутизации. Одной из наиболее популярных моделей является **Model-View-Controller** (MVC). В этой модели различают методы доступа к данным (чаще всего база данных, Model), методы управления обработкой http-запросов (Controller) и методы генерации HTML-кода (View). Контроллер является связующим звеном и изолирует методы отображения от методов работы с данными в базе.

Особое значение для разработки Back-End имеет [Middleware](middleware.md).

Огромную важность представляют задачи обработки данных в СУБД. Различают два принципиально разных подхода: **реляционную модель** (SQL) и **NoSQL** (кэширующая база с иерархическим представлением данных). Реляционная модель отлично подходит для выполнения сложных запросов отбора данных, тогда как NoSQL обеспечивает великолепное время поиска слабо-структурированных данных. На практике встречаются комбинированные модели, в которых данные хранятся в SQL СУБД, но часть из них кэшируется в NoSQL (например, в Redis).

При использовании реляционной модели распространено два подхода, которые легко комбинируются: для выполнения запросов используется client-side SQL, либо используются **хранимые процедуры**, размещённые и исполняемые СУБД. В общем случае, хранимые процедуры обеспечивают значительно лучшую производительность, т.к. минимизируют сетевой трафик, данные находятся максимально близко, кэширование запросов на СУБД (**Execution plan**/план исполнения) выполняется. Тем не менее, разработка хранимых процедур - это отдельная компетенция, развитие которой может занимать годы (особенно в случае, если разработчик осуществляет анализ плана выполнения SQL-запросов и занимается оптимизацией структуры базы данных).

Несмотря на то, что многие web-приложения непосредственно формируют SQL-запросы, этот подход не считается оптимальным из-за высокой вероятности ошибок и избыточных действий. Обычно, за генерацию SQL-запросов отвечает специализированный framework - **Object-Relational Mapping (ORM)**. Современные ORM позвололяют описывать модель базы данных в терминах объектов языка программирования и обрабатывать результаты запросов, как контейнеры (списки, векторы, словари, и т.д.). Такой подход позволяет разработчикам без навыков работы с SQL использовать СУБД (на практике, конечно же, SQL знать нужно). К дополнительным функциям ORM можно отнести:

1. Контроль соответствия объектной модели в коде с фактической структурой таблиц в базе данных
2. Управление миграциями, т.е. создание скрипта обновления структуры таблицы в случае, если вышла новая версия приложения
3. Кэширование результатов запрос на client-side

Классическим примером ORM является Entity Framework для Microsoft ASP.NET.

Следует обратить внимание, на глубокую связь между языком программирования и СУБД. Не смотря на то, что кросс-платформенные связи возможно (приложение на C# может использовать MongoDB, а приложения Node.js может работать с традиционными SQL СУБД), тем не менее в случае использования "родного" инструментария эффективность решения значительно выше, чем кросс-платформенного. По этой причине, при выборе технологического стека следует рассматривать именно экосистемы, а не некоторый произвольным образом выбранные части одной большой головоломки.

<a name="nodejs"></a>
### Особенности технологического стека Node.js

[Node.js](https://nodejs.org/en/) - это программная платформа, ключевыми компонентами которой является движок **V8** (осуществляющий трансляцию JavaScript-кода в машинный код) и Runtime, разработанного на C++. Бинарный код, полученный из JavaScript, выполняется всегда в одном потоке (основном), но блокирующие операции ввода-вывода Runtime исполняет в отдельных рабочих потоках. Как результат, обеспечивается высокая производительность приложений Node.js, в частности, web-сервера Express.

Ключевая особенность стека - фокус на модульности решений. Типовое приложение включает сотни и тысячи зависимостей (*dependencies*) от библиотек (*packages*). Для управления зависимостями используются специализированные инструменты - [менеджеры зависимостей npm и yarn](npm-vs-yarn.md).

Разработчики стремяться к уменьшению количества зависимостей, а также фокусировке каждого package на решении конкретной специализированной функции. В практическом плане, это приводит к постепенному переходу к более модульным и компактным продуктам. Так, например, самый популярный web-сервер [Express](https://expressjs.com/ru/) постепенно заменяется [Koa.js](https://koajs.com/), который разрабатывается той же группой программистов. По ссылке доступна [статья](express.md) с описанием основных возможностей Express.

Следует заметить, что огромное community и доступность сотен тысяч open-source библиотек делают эко-систему Node.js и JavaScript фантастически популярной. В значительной степени, успешность разработки web-приложения на Node.js зависит от разумно выбранных шаблонов и подходящих к шаблонам, надёжных библиотек.

Наиболее популярной технологией хранения и поиска данных является NoSQL (Not only SQL). Популярная СУБД является [MongoDB](https://www.mongodb.com/). Часто в проектах используется **Object Document Mapper (ODM)** под названием [Mongoose](https://mongoosejs.com/). Вместе с тем, с ORM для реляционных баз данных всё тоже прекрасно. Популярные ORM: [Sequelize](https://sequelize.org/), [TypeORM](https://typeorm.io/#/), [Bookshelf](https://bookshelfjs.org/) и [Objection](https://vincit.github.io/objection.js/).

Райян Даль, создатель Node.js осуществляет разработку нового продукта [Deno](https://deno.land/). С сильными и слабыми сторонами обоих *runtimes* можно [ознакомиться здесь](deno.md).

Для повышения производительности, могут быть использованы native-библиотеки, компирирующиеся из C/C++. Для сборки часто используется специальный модуль [node-gyp](https://www.npmjs.com/package/node-gyp).

<a name="aspnet"></a>
### Особенности технологического стека ASP.NET Core 5

Основным языком программирования ASP.NET Core является C#. Для описания шаблонов Html-страниц может использоваться Razor-синтаксис, который позволяет встраивать в верстку C#-код, при её генерации сервером. ASP.NET Core поддерживает модель MVC.

Сильными сторонами ASP.NET Core является встроенная поддержка ORM Entity Framework, позволяющая работать с базой данных, используя LINQ-запросы, обращаясь к СУБД, как к контейнеру объектов C#. Можно выбрать один из двух вариантов синтаксиса запросов.

Extension methods:

```csharp
var results = context.Contacts.SelectMany(c => c.SalesOrderHeaders)
    .OrderBy(c => c.SalesOrderDetails.Count)
    .Select(c => new { c.SalesOrderDetails.Count });
```

LINQ Syntax:

```csharp
IQueryable<SalesOrderDetail> query =
    from sale in context.SalesOrderDetails
    where sale.SalesOrderID == s
    select sale;
```

Из других удобных особенностей C#: поддержка Dependency Injection.

В качестве web-сервера рекомендуется использовать **Microsoft Internet Information Server**. Для отладки кода можно использовать встроенный сервер **Kestrel**. Статья по настройке IIS и SQL Server доступна [здесь](iis.md).

Считается, что web-приложения на ASP.NET Core обладают высокой производительностью и надёжностью.

Приложения ASP.NET Core могут работать как под Windows, так и под Linux (Apache).

<a name="java"></a>
### Особенности технологического стека Java

Сильная сторона Java - огромное количество мощных библиотеки, развитая эко-система. Основной разработчик Java - корпорация Oracle, поставляет два **Java Development Kit** (JDK): платный, надежный, с длительным циклом поддержки (LTS) **Oracle JDK** и бесплатный экспериментальный **Open JDK**. Статья [За Oracle JDK нужно будет платить. Какие теперь варианты?](https://habr.com/ru/company/epam_systems/blog/430084/) 

Существуют альтернативные релизы Open JDK, например: [Amazon Corretto](https://docs.aws.amazon.com/corretto/index.html), [Zulu OpenJDK](https://www.azul.com/downloads/zulu-community/?package=jdk), [Alibaba Dragonwell OpenJDK](http://dragonwell-jdk.io/). Существуют специализированные виртуальные машины для компиляции Java в native code, например: [GraalVM](https://www.graalvm.org/).

Ключевой библиотекой для взаимодействия с базой данных является [Hibernate ORM](http://hibernate.org/orm/).

[Apache Struts](https://struts.apache.org/) - фреймворк для разработки web-приложений с использованием шаблона проектирования MVC.

Набор библиотек [Spring](https://spring.io/) содержит множество инструментов, исключительно эффективных для разработки корпоративных приложений: Serverless, Cloud, Microservices, Reactive, Event Driven.

A type-safe HTTP client for Android and Java - [Retrofit](https://square.github.io/retrofit/).

Рекомендуется к прочтению статья [Top 10 Libraries every Java Developer should know](https://towardsdatascience.com/top-10-libraries-every-java-developer-should-know-37dd136dff54).

<a name="serverless"></a>
## Serverless Backend

Одним из популярных направлений разработки Backend является Serverless. Основная идея состоит в делегировании функций управления ресурсами провайдеру облачных услуг. Наиболее популярными являются [Google Firebase](https://firebase.google.com/) и [AWS Lambda](https://aws.amazon.com/ru/lambda/).

Приложение использует предоставленный облачным провайдером SDK, либо REST API для выполнения типовых задач:

1. Аутентификация пользователей
2. Сохранение данных в базе (чаще всего NoSQL)
3. Хранение статических файлов (Hosting)
4. Системы машинного обучения

Компания, разрабатывающая мобильное, или web-приложение не создаёт серверов – она использует SDK, а обработка запросов, масштабирование (развертывание дополнительных instances) выполняются самой платформой (Firebase, AWS).

В случае использования AWS Lambda, или Firebase Cloud Functions – могут быть разработаны специализированные функции, выполняющиеся на сервере, что позволяет добавить функционал, изначально отсутствующий у облачных провайдеров.

Достоинства:

1. Отличное масштабирование
2. Высокая надёжность (не так для Firebase Realtime Database)
3. Очень лёгкая интеграция сервисов в клиентское ПО
4. Огромное разнообразие сервисов аутентификации

Недостатки:

1. Оплата по факту использованных ресурсов – можно легко выйти за бюджет и даже разориться, из-за небольших недоработок в коде
2. Высокая, фактическая, стоимость – в том числе, есть неявные статьи расходов, которые сложно запланировать, не имея значительного опыта в использовании сервисов
3. В России отсутствуют центры обработки данных Amazon, Microsoft и Google. Время отклика хуже, чем в развитых странах мира
4. Возможно введение «цифрового железного занавеса» с любой из сторон (санкции США, либо блокировки РосКомНадзора)

Наиболее сложной технической проблемой при работе serverless-приложений является эффективность масштабирования. Ключевая проблема состоит в том, что когда облачный провайдер понимает, что требуется запустить ещё одну копию приложения (в контейнере) этот запуск (start-up) занимает некоторое время (0.5-5 мс). Если процесс не достаточно хорошо оптимизирован, то время выполнения запроса может изменяться в широком диапазоне. В случае активного использования микро-сервисов (т.е. выполнения нескольких атомарных операций в рамках одной бизнес-операции), время выполнения может быть значительным. Благодаря повторному использованию ранее запущенных машин, повторное выполнение запросов осуществляется существенно быстрее. Т.к. при снижении нагрузку облако удаляеет "лишнее" контейнеры, при "рваной" нагрузке система в целом тратит много времени на подъём и освобождение контейнеров (эти задачи включаются в счёт на оплату и это приводит к низкому КПД - значительную часть расходов составляют не целевые действия системы). В случае, если нагрузка равномерная, гораздо удобнее использовать типовой подход с выделенным сервером (или несколькимим серверами). Провайдеры пытаются решить проблему внедряя продукты с быстрым запуском приложения, например, заранее компилируя Java-код в нативный код (см. [GraalVM](https://www.graalvm.org/)).

Видео: [Serverless Doesn't Make Sense](https://www.youtube.com/watch?v=AuMeockiuLs) by Ben Awad

Статьи: [Playing with GraalVM on Windows 10 and WSL2](https://tsuyoshiushio.medium.com/playing-with-graalvm-on-windows-10-8be837007b33) by Tsuyoshi Ushio, [Is Quarkus the future of Java?](https://medium.com/swlh/is-quarkus-the-future-of-java-b664c5e79381) by Ben Khemis

Важные термины:

**Federated Identity** – это возможность выполнять аутентификацию пользователя по его/её логину в других крупных системах (Google, Apple, Facebook, Twitter, GitHub, Microsoft).

**Provisioning Resources** – выделение/предоставление ресурсов.

# Шаблоны проектирования

При разработке web-приложений шаблоны проектированию применяются порой, существенно чаще, чем при разработке приложений других типов.

<a name="crud"></a>
## CRUD и RESTful

Акроним расшифровывается как Create, Read, Update, Delete/Destroy и ссылается на четыре наиболее универсальных операций работы с, практически, с любой сущностью. Под сущностью подразумевается некоторое понятие из конкретной прикладной области, например: пользователь, счёт в банке, запись в блоге.

С CRUD тесно связано шаблон проектирования RESTFul, который выполняет mapping HTTP Routes и CRUD. Шаблон является универсальным, с ним знакомо большинство пользователей и в большинстве случаев, web-разработчиком достаточно перечислить список сущностей, чтобы понять ожидаемых результат, объём работы и её сложность.

Пример определения HTTP Routes для сущности "собака" в RESTful:

| Команда |    Пример URL   | HTTP Verb |                         Описание                         |
|:-------:|:---------------:|:---------:|:--------------------------------------------------------:|
|  Index  | /dogs           |    GET    | Вывести список всех собак                                |
|   New   | /dogs/new       |    GET    | Вывести форму для ввода данных о новой собаке            |
|  Create | /dogs           |    POST   | Добавить новую собаку в базу данных                      |
|   Show  | /dogs/:id       |    GET    | Показать информацию об одной собаке                      |
|   Edit  | / dogs/:id/edit |    GET    | Показать форму для редактирования информации о собаке    |
|  Update | /dogs/:id       |    PUT    | Обновить данные о собаке, а потом перейти куда-нибудь    |
| Destroy | /dogs/:id       |   DELETE  | Удалить информацию о собаке, а потом перейти куда-нибудь |

Критика REST API: в следующих случаях использование REST API затруднено:

1. Большое количество операций Upload (они вообще не рассматриваются в схеме)
2. Случаи, когда пользовательявным образом указывает уникальный идентификатор ресурса при его создании
3. При использовании групповых операций, которые REST API вообще не рассматривает

### Выбор клиентской библиотеки для взаимодействия с REST API

Наиболее популярными средствами доступа к REST API являются [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API), [jQuery ajax](https://api.jquery.com/jquery.ajax/) и [Axios](https://www.npmjs.com/package/axios).

Считается, что fetch и jQuery ajax больше подходят для небольших приложений, в первую очередь из-за небольшого размера библиотек (minimal footprint). Axios прекрасно подходит для сложных приложений, в том числе, благодаря мощному механизму Axios Interceptors, позволяющему централизованно встраивать дополнительных код при обработке запросов и формировании ответов. Это значительно повышает удобство поддержки JWT.

### Критика CRUD и RESTful

Несмотря на очевидную популярность CRUD и RESTful среди популяризаторов, консультантов и авторов online-курсов, среди профессиональных разработчиков отношение скорее негативное. Это связано, в первую очередь, с тем, что CRUD подходит для простых приложений, но начинает создавать множество проблем в сложных, активно развивающихся приложениях.

Рекомендуются к прочтению следующие статьи: [Why Are You Still Creating CRUD APIs?](https://levelup.gitconnected.com/why-are-you-still-creating-crud-apis-8790ca261bfb) by Nicklas Millard, [Is CRUD Bad for REST?](https://www.infoq.com/news/2009/07/CRUDREST/) by Boris Lublinsky, [Using CQRS with Event Sourcing or – what’s wrong with CRUD?](https://blog.softmemes.com/2016/11/12/using-cqrs-with-event-sourcing/) by Kristian Freed, [Why CRUD might be what they want, but may not be what they need](http://codebetter.com/iancooper/2011/07/15/why-crud-might-be-what-they-want-but-may-not-be-what-they-need/) by Ian Cooper, [CRUD is an antipattern](https://verraes.net/2013/04/crud-is-an-anti-pattern/) by Mathias Verraes.

Личный опыт автора связан с разработкой приложений, в которых применение CRUD было осложнено тем, что:

* требовалось большое количество операций Upload, которые не всегда удачно "ложаться" в CRUD
* при работе с одной сущностью, использовались разные идентификаторы (а не один, явно обозначенный идентификатор сущности), или группы ключей
* требовалось реализовывать групповые операции, которые в типовых CRUD-приложениях почти не встречаются

<a name="mvc"></a>
## MVC

Акроним расшифровывается как **Model-View-Controller**. Шаблон рекомендуется отделять модель (способ представления и хранения данных) от view - уровня представления (пользовательский интерфейс). Связующим звеном является Controller, в котором, чаще всего выполняется бизнес логика. Уровень представления генерирует события, которые обрабатываются контроллером, контроллер обращается за данными к Model и передаёт эти данные во View для формирования пользовательского интерфейса.

Шаблон позволяет достаточно легко реализовывать схемы, в рамках одной системы может существовать несколько разных пользовательских интерфейсов (например, для web и для мобильных устройств). Также, модификация структуры данных, или переход на другую СУБД является существенно менее сложной задачей, чем в случае, если разделение на уровни не осуществляется.

<a name="cqrs"></a>
## CQRS

CQRS - _Command-query separation_. Шаблон проектирования часто применяется при разработке Backend, возвращающий JSON. Ключевое требование - метод должен быть либо командой, выполняющей какое-то действие, либо запросом, возвращающим данные, но не одновременно. **Команда**: выполняет какое-то действие модифицирующее состояние системы, но не возвращает значений. **Запрос**: отвечает внешнему коду на некоторый вопрос не изменяя состояние системы, возвращая некоторое значение.

Разделение кода на команды и запросы позволяет значительно упростить масштабирование системы. Например, можно настроить репликацию базы данных, в которой главная копия выполняет команды (Insert/Update/Delete), а вспомогательные копии - только отдают данные (Select). Можно утверждать, что модель упрощает оптимизацию для операций чтения (Query) и записи (Command).

Довольно часто совместно с CQRS используют шаблон проектирования **Mediator**, который встраивается в контроллер (MVC) и переадрессует запросы специализированным классам, в которых реализованы внутренние классы для выполнения команд и запросов. В приведённом ниже примере, это осуществляется посредством вызова Mediator.Send():

```csharp
namespace API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class ActivitiesController : BaseApiController
    {
        [HttpGet]   // GET api/activities
        public async Task<ActionResult<IEnumerable<Activity>>> GetActivities()
        {
            // Переадрессуем запрос в подкласс класса List из пространства имён
            // Application.Activities
            var values = await Mediator.Send(new List.Query());

            // Возвращаем успешный Http Status Code и полученные данные
            return Ok(values);
        }
```

<a name="reverse_proxy"></a>
# Reverse Proxy

В промышленных системах web-приложения доступны не напрямую, а через так называемые [Reverse Proxy](https://medium.com/intrinsic/why-should-i-use-a-reverse-proxy-if-node-js-is-production-ready-5a079408b2ca). Это делается по нескольким причинам:

1. Защищённость системы: за зващиту отвечает специализированные инструмент
2. Reverse Proxy работает с сертификатами безопасности и выполняет архивирование ответа сервера (эффективность reverse proxy может быть выше на 15-50%)
3. Осуществляется проверка и подмена полей http-запросов в MIME-заголовке
4. Повышенная производительность и надёжность: Reverse Proxy может распределять запрос между несколькими worker-ами (например, между несколькими копиями Node.js)
5. Обеспечивают поддержку современных протоколов, в частности [HTTP/2](http2.md). Поддержка HTTP/2 позволяет использовать одно TCP-соединение для нескольких http-запросов, а так же загружать статические документы с упреждением. Например, CSS-файл может начать загружаться до того, как будет завершена загрузка html-документа

Резюмируя: использование Reverse Proxy позволяет значительно увеличить производительность системы, снизить нагрузку на сетевую подсистему, а также улучшить безопасность системы.

В качестве таких прокси часто используются Microsoft Internet Information Server, [nginx](https://nginx.org/ru/) и [HAProxy](http://www.haproxy.org/).

На официальном сайте **nginx** доступна бесплатная книга о защите web-приложений от внешних атак.

<a name="tools"></a>
# Инструментальные средства для web-разработки

## Visual Studio Code (с Plug-Ins)

Наиболее универсальный IDE со множеством plug-in-ов [Microsoft Visual Studio Code](https://code.visualstudio.com/). Мои любимые Plug-Ins:

1. [Bookmarks](https://marketplace.visualstudio.com/items?itemName=alefragnani.Bookmarks) by Alessandro Fragnani
2. [Bracket Pair Colorizer 2](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2) by CoenraadS
3. [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme) by Philipp Kief
4. [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)
5. [Tabnine Autocomplete AI](https://marketplace.visualstudio.com/items?itemName=TabNine.tabnine-vscode) by Tabnine. ВНИМАНИЕ! Огромное потребление ОЗУ. Создаёт десятки процессов по ~60 Мб каждый
6. [NuGet Gallery](https://marketplace.visualstudio.com/items?itemName=patcx.vscode-nuget-gallery) by pcislo

Дополнительно рекомендуется установить параметры:

1. Шрифт для редактора VSCode - **FireCode** (с поддержкой лигатур). Доступен на [Google Fonts](https://fonts.google.com/specimen/Fira+Code?query=Fira+Code).
2. Убрать Mini-Map, который загромождает экран. **Текстовый редактор -> Мини-Карта -> Enabled** установить в False
3. Автоматическое сохранение кода при переходе из VSCode в другое окно: **Текстовый редактор -> Файлы -> Auto Save** установить в onWindowChange
4. Не выводить сообщение о превышении длины комментария при commit-е в GitHub на 50-ом символе. **Расширения -> Git -> Input Validation Subject Length** установить в 72

## Sublime Text 4

Популярный HTML/CSS редактор с поддержкой Zen-программирования - [Sublime Text 4](https://www.sublimetext.com/). Под Zen-программированием подразумевается возможность частичного ввода информации и автоматической генерации html-тэгов при нажатии кнопки **Tab**. Например, для текста: `div.worker` при нажатии на кнопку **Tab** будет сформирована следующая html-разметка:

```html
<div class="worker"></div>
```

Мета-язык Zen Coding может быть достаточно комплексным и при наличии навыков, кратно ускорять разработку html-верстки. См. также [Emmet](https://packagecontrol.io/packages/Emmet). Доступен [Plug-In](https://marketplace.visualstudio.com/items?itemName=MadsKristensen.ZenCoding) для Visual Studio.

Sublime Text 4 является условно-бесплатным и очень часто используется разработчиками на MacOS. В этой операционной системе также часто используется редактор кода [Brackets](http://brackets.io/).

## Другие инструменты

Платный, но очень мощный инструмент - [JetBrains WebStorm](https://www.jetbrains.com/webstorm/).

Облачные IDE: [GitPod](https://www.gitpod.io/), [CodeAnywhere](https://codeanywhere.com/), [Github Codespaces](https://github.com/features/codespaces).

Песочницы для быстрого прототипирования и экспериментирования: [CodePen](https://codepen.io/), [CodeSandBox](https://codesandbox.io/) и [StackBlitz](https://stackblitz.com/).

Исключительно важным продуктом для отладки REST API является [Postman](https://www.postman.com/). Этот продукт позволяет, посредством GUI, сконструировать любой http(s) запрос и проанализировать полученный результат. Продукт считается индустриальным стандартом. Схожий функционал есть у консольного приложения [CURL](https://curl.haxx.se/), но в этом продукте нет такого мощного и удобного графического пользовательского интерфейса, как у Postman.

Postman может работать как Desktop-приложение, так и через web-интерфейс. В случае web-интерфейса запросы выполняются через облачный proxy, что позволяет применять продукт в корпоративных сетях, с ограничениями в разрешённых сетевых взаимодействиях.

# Осталось "за кадром"

[Gatsby.js](https://www.gatsbyjs.com/) - генератор статических сайтов. Ключевая идея: сайт генерируется с использованием базы данных и шаблонов периодически, например, раз в сути, по ночам. Все артефакты являются окончательно сформированными (минимизированными, сжатыми). Вычислительные ресурсы сервера используются максимально эффективно, скорость работы сайта - максимально высокая.

[Next.js](https://nextjs.org/) - популярный фреймворк для Server-Side Rendering. Основывается на React.js.

<a name="extra"></a>
# Дополнительная информация

## Cheatsheets

Статья FAM [8 Great Cheatsheets for Web Devs](https://javascript.plainenglish.io/8-amazing-cheatsheet-resources-for-web-developers-74a50fde89ba) содержит ссылки на различные Cheatsheets, исключительно полезные для web-разработки.

[CanIUse](https://caniuse.com/) - поддержка браузерами различных технологий.

[GRID](https://grid.malven.co/) - CSS/Flexbox.

Cheatsheet [Regular Expressions](https://cheatography.com/davechild/cheat-sheets/regular-expressions/).

## Heroku

Почему [Heroku](heroku.md) так важен для web-разработчика.

## GitHub Pages

GitHub предоставляет бесплатный хостинг для статических сайтов с URL: https://[account_name].github.io/[repo_name]

Для того, чтобы активировать GitHub Pages необходимо в разделе "Settings -> Pages" репозитария активировать функцию. GitHub Pages является бесплатным для публичных репозитариев. Если репозитарий является Private, то необходимо выбрать платный тарифный план.

Статический сайт рекомендуется публиковать в отдельном branch-е репозитария. Предполагается, что в ветке main/master находятся исходные материалы для сборки статического сайта, а сам статический сайт размещается в отдельной ветке, чтобы экономить дисковое пространство. В указанной, в управляющей консоли Pages, ветке осуществляется поиск файла "index.html", который и будет входной точкой статического сайта.

## Favicon

Что такое **Favicon**, на отсутствие которой ругается Google Chrome в Developer Console (F12)?

```
.../favicon.ico Failed to load resource: the server responded with a status of 404 (Not Found)
```

Это иконка вашего web-приложения, которую браузер отображает в закладке (Page Tab).

## Особенные термины

**Slug** – это то уникальная строка идентификатор, понятная человеку (в отличие от ID) и содержащая только "безопасные" символы:

* 0-9
* a-z (общепринято - в нижнем регистре)
* символ "Тире/минус"
* символ "Нижнее подчеркивание"

В общем случае Slug - это легко читаемый человеком идентификатор чего-либо. Часто используется в шаблоне маршрута http-запроса.

**Chunks** - некоторая часть web-приложения (оформленная как bundle), которая может содержать JavaScript, CSS, HTML-разметку. Разделение на chunks позволяет реализовывать, например, отложенную загрузку («загрузка по требованию») React-компонента с целью минимизировать сетевую нагрузку.

## OpenJS Foundation

[Организация](https://openjsf.org/projects/) которая стоит за множеством популярных ориентированных на JavaScript-проектов, в том числе: jQuery, Node.js, Express и т.д.
