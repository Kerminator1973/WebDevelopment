# Вспомогательные инструментальные средства

В случае асинхронного выполнения работы, или при необходимости использования общего кэша для нескольких копий web-серверов, часто используется **in-memory key-value** система. Примеры таких систем: [Redis](https://redis.io/), [Memcached](https://memcached.org/).

Статья для ознакомления [Using Redis pub/sub with Node.js](https://blog.logrocket.com/using-redis-pub-sub-node-js/) by Victor Jonah. В статье указывается, что [Apache Kafka](https://kafka.apache.org/) намного быстрее, чем Redis в части поддержки шаблона проектирования publish/subscribe. [RabbitMQ](https://www.rabbitmq.com/) также гораздо лучше работает в качестве выделенного message broker-а, но Redis совмещает и **memory store**, и **pub/sub**.

Kafka - это распределённая платформа потоковой передачи событий, предназначенная для обработки потоков данных в реальном времени. Широко используется для создания высокопроизводительных, отказоустойчивых и масштабируемых конвейеров данных, аналитики в реальном времени и архитектур, управляемых событиями.

Kafka решает ограничения обработки больших объёмов данных в реальном времени с высокой пропускной способностью, которые характерны для RabbitMQ и ActiveMQ. Ключевые особенности Kafka: репликация на несколько узлов, сообщения сохраняются на диске, поддерживает Event-Driven архитектуры.

В случае, если необходимо организовать полнотекстовый поиск по некоторым структурированным данным, часто применяется [ElasticSearch](https://github.com/elastic/elasticsearch). Движок, в котором используется т.н. **обратный индекс**. Суть обратного индекса состоит в том, что в качестве ключа хранится искомое слово, а в качестве значения - список ссылок на документы, в которых это слово используется. В общем случае, поиск по слову осуществляется очень быстро, но операция добавления может быть долгой. В качестве альтернативы можно рассматривать библиотеку [Apache Lucene](https://lucene.apache.org/) и разработанный на её основе продукт - [Apache Solr](https://solr.apache.org/).

Следует принять во внимание, что в Postgres есть собственный движок  полнотекстового поиска (Full‑Text Search, FTS) - **Tsearch2**. Механизм преобразует текстовые данные в нормализованные лексемы (основы слов) и строит инвертированный индекс для быстрого поиска. Ключевые компоненты:

Типы данных:

- tsvector — представление документа как набора лексем с позициями
- tsquery — запрос в формате поискового выражения (с операторами &, |, !, <-> и др.)

Функции и операторы:

- to_tsvector() — преобразует текст в tsvector
- to_tsquery() — преобразует поисковый запрос в tsquery
- @@ — оператор соответствия (tsvector @@ tsquery)
- ts_rank() — ранжирует результаты по релевантности

Словари и стемминг:

- Используются словари для приведения слов к нормальной форме (например, английский, русский стеммеры)
- Поддерживается мультиязычность

Индексы:

- GIN (Generalized Inverted Index) — оптимален для FTS
- GiST — менее эффективен, но поддерживает дополнительные операции

Пример использования:

```sql
-- Создание индекса
CREATE INDEX idx_fts_content ON articles USING GIN (to_tsvector('russian', content));

-- Поиск документов, содержащих «поиск» или «база данных»
SELECT title, ts_rank(to_tsvector('russian', content), query) AS rank
FROM articles, to_tsquery('russian', 'поиск | база & данных') AS query
WHERE to_tsvector('russian', content) @@ query
ORDER BY rank DESC;
```

Для сложных сценариев, таких как: масштабирование b нечёткий поиск, имеет смысл рассмотреть plugin **pg_trgm** или внешние системы (Elasticsearch/Solr).
